<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, viewport-fit=cover">
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#e31919">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Foodie">
  <link rel="apple-touch-icon" href="icons/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="icons/icon-192.png">
  <title>Foodie - Trusted Restaurant Reviews</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html { overflow-x: hidden; max-width: 100%; -webkit-text-size-adjust: 100%; }
    body { font-family: system-ui, -apple-system, sans-serif; background: #eee; min-height: 100vh; overflow-x: hidden; max-width: 100vw; width: 100%; -webkit-text-size-adjust: 100%; touch-action: manipulation; }
    #app { max-width: 100%; overflow-x: hidden; width: 100%; }
    .top-bar { position: fixed; top: 0; left: 0; right: 0; width: 100%; max-width: 100vw; background: #e31919; color: white; z-index: 90; }
    .header { padding: 12px 16px; display: flex; align-items: center; gap: 16px; }
    .menu-btn { background: none; border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 4px 8px; }
    .menu-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 100; }
    .menu-sidebar { position: fixed; top: 0; left: 0; bottom: 0; width: 280px; max-width: 85vw; background: #0049AD; z-index: 101; padding-top: 20px; }
    .menu-sidebar-header { text-align: center; padding: 24px 16px; background: #003c90; }
    .menu-sidebar-avatar { width: 80px; height: 80px; border-radius: 50%; background: #4b8ce6; color: white; display: flex; align-items: center; justify-content: center; font-size: 2rem; font-weight: 600; margin: 0 auto 12px; }
    .menu-sidebar-name { color: #ffac46; font-size: 1.3rem; font-weight: 500; }
    .menu-sidebar-nav { padding: 16px 0; }
    .menu-sidebar-item { display: block; width: 100%; padding: 14px 20px; text-align: left; border: none; background: none; color: white; font-size: 1.1rem; cursor: pointer; }
    .menu-sidebar-item:hover { background: rgba(255,255,255,0.1); }
    .logo { font-size: 1.4rem; font-weight: 600; }
    .header-logo { height: 32px; width: auto; object-fit: contain; }
    
    .signup-page { min-height: 100vh; display: flex; flex-direction: column; }
    .signup-top { width: 100%; min-height: 40vh; background-color: #9e1212; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 40px 20px; }
    .signup-logo-img { width: 200px; max-width: 80%; height: auto; }
    .signup-bottom { flex: 1; width: 100%; background-color: #014288; padding: 45px 24px 60px; display: flex; flex-direction: column; align-items: center; }
    .signup-actions { width: 100%; max-width: 320px; display: flex; flex-direction: column; align-items: center; gap: 12px; }
    .signup-btn { width: 100%; padding: 16px; font-size: 1.1rem; font-weight: 600; background: transparent; color: white; border: 2px solid white; border-radius: 28px; cursor: pointer; }
    .signup-btn:hover { background: rgba(255,255,255,0.2); }
    .signup-demo-label { color: rgba(255,255,255,0.85); font-size: 0.95rem; margin-bottom: 8px; text-align: center; }
    .signup-bottom input::placeholder, .signup-bottom input::-webkit-input-placeholder { color: rgba(255,255,255,0.6); }
    .signup-bottom select option { background: #014288; color: white; }
    
    .tabs { display: flex; justify-content: space-around; padding: 10px 0; border-top: 1px solid rgba(255,255,255,0.3); }
    .tab { display: flex; flex-direction: column; align-items: center; padding: 12px 14px; color: rgba(255,255,255,0.7); cursor: pointer; border: none; background: none; font-size: 0.95rem; min-width: 48px; -webkit-tap-highlight-color: transparent; }
    .tab:hover, .tab.active { color: white; }
    .tab.active { background: rgba(255,255,255,0.2); border-radius: 8px; }
    
    .app-content { padding-top: 120px; min-height: 100vh; display: flex; justify-content: center; width: 100%; max-width: 100%; }
    body.chrome-banner-visible .top-bar { top: 52px; }
    body.chrome-banner-visible .app-content { padding-top: 172px; }
    body.chrome-banner-visible .signup-page { padding-top: 52px; }
    .app-content-inner { flex: 1; min-width: 0; max-width: 720px; width: 100%; }
    .app-content-inner.map-view, .app-content-inner.add-view { max-width: 720px; width: 100%; }
    .main { padding: 16px; width: 100%; box-sizing: border-box; }

    .ptr-indicator { position: fixed; top: 120px; left: 0; right: 0; height: 56px; display: flex; align-items: center; justify-content: center; gap: 8px; background: #f5f5f5; color: #666; font-size: 0.9rem; z-index: 50; transform: translateY(-100%); transition: transform 0.2s ease, opacity 0.2s ease; opacity: 0; pointer-events: none; }
    .ptr-indicator.visible { opacity: 1; }
    .ptr-indicator .ptr-spinner { width: 24px; height: 24px; border: 2px solid #e31919; border-top-color: transparent; border-radius: 50%; animation: ptr-spin 0.8s linear infinite; }
    .ptr-indicator:not(.refreshing) .ptr-spinner { display: none; }
    .ptr-indicator.refreshing .ptr-spinner { display: block; }
    @keyframes ptr-spin { to { transform: rotate(360deg); } }
    
    .feed-compose { background: white; border-radius: 8px; padding: 12px 16px; margin-bottom: 12px; box-shadow: 0 1px 2px rgba(0,0,0,0.08); display: flex; align-items: center; gap: 12px; cursor: pointer; }
    .feed-compose:hover { background: #f8f8f8; }
    .feed-compose-avatar { width: 48px; height: 48px; border-radius: 50%; background: #e31919; color: white; display: flex; align-items: center; justify-content: center; font-weight: 600; font-size: 1.1rem; flex-shrink: 0; }
    .feed-compose-text { flex: 1; color: #666; font-size: 0.95rem; }
    
    .review-card { background: white; border-radius: 8px; overflow: visible; box-shadow: 0 1px 2px rgba(0,0,0,0.08); margin-bottom: 12px; }
    .review-card-header { display: flex; align-items: flex-start; gap: 12px; padding: 12px 16px; overflow: visible; border-radius: 8px 8px 0 0; }
    .review-avatar { width: 48px; height: 48px; border-radius: 50%; background: #0a66c2; color: white; display: flex; align-items: center; justify-content: center; font-weight: 600; font-size: 1rem; flex-shrink: 0; }
    .review-avatar.self { background: #e31919; }
    .review-header-meta { flex: 1; min-width: 0; overflow: visible; }
    .review-header-top { display: flex; align-items: center; gap: 6px; flex-wrap: nowrap; overflow-x: auto; overflow-y: hidden; -webkit-overflow-scrolling: touch; padding-bottom: 4px; }
    .review-header-top > * { flex-shrink: 0; }
    .review-edit-btn { margin-left: auto; background: #e31919; color: white; border: none; font-size: 0.85rem; cursor: pointer; padding: 6px 12px; border-radius: 6px; }
    .review-edit-btn:hover { background: #c61616; }
    .review-by { font-weight: 600; color: #000; font-size: 0.95rem; }
    .connect-btn { width: 28px; height: 28px; border-radius: 50%; border: 1px solid #0a66c2; background: white; color: #0a66c2; font-size: 1rem; line-height: 1; cursor: pointer; display: inline-flex; align-items: center; justify-content: center; flex-shrink: 0; }
    .connect-btn:hover { background: #0a66c2; color: white; }
    .connect-btn.pending { border-color: #999; color: #999; cursor: default; }
    .review-connection { font-size: 0.75rem; color: #666; background: #f3f2ef; padding: 1px 6px; border-radius: 4px; }
    .review-connection.badge-discover { color: #7c4dff; background: #ede7f6; }
    .badge-verified { font-size: 0.7rem; color: #0a7; background: #e6f7f0; padding: 2px 6px; border-radius: 4px; }
    .badge-again { font-size: 0.7rem; color: #666; background: #f3f2ef; padding: 2px 6px; border-radius: 4px; }
    .badge-trust { font-size: 0.7rem; color: #0a66c2; background: #e8f4fc; padding: 2px 6px; border-radius: 4px; }
    .mutual-connections { font-size: 0.8rem; color: #0a66c2; margin-top: 4px; }
    .review-date { font-size: 0.8rem; color: #666; margin-top: 2px; }
    .review-restaurant { font-weight: 600; color: #e31919; font-size: 1rem; margin-top: 4px; }
    .review-card-body { padding: 0 16px 12px 76px; }
    .review-text { line-height: 1.5; font-size: 0.95rem; color: #333; }
    .review-rating { margin-top: 6px; font-size: 1rem; }
    .review-actions { display: flex; align-items: center; padding: 4px 16px 4px 76px; border-top: 1px solid #f3f2ef; overflow-x: auto; overflow-y: hidden; -webkit-overflow-scrolling: touch; gap: 0; -webkit-tap-highlight-color: transparent; }
    .review-actions-secondary { display: flex; align-items: center; padding: 4px 16px 8px 76px; gap: 12px; flex-wrap: wrap; }
    .review-actions-secondary .review-list-dropdown { position: relative; display: inline-block; }
    .review-action-btn { flex: 0 0 auto; display: flex; align-items: center; justify-content: center; gap: 4px; padding: 8px 10px; background: none; border: none; color: #666; font-size: 0.8rem; cursor: pointer; white-space: nowrap; touch-action: manipulation; -webkit-tap-highlight-color: rgba(0,0,0,0.08); }
    .review-action-btn:hover { background: #f3f2ef; color: #0a66c2; }
    .review-action-btn.liked { color: #e31919; }
    
    .add-review-page { display: flex; flex-direction: column; gap: 16px; position: relative; }
    .add-review-input { width: 100%; padding: 14px; font-size: 1rem; border: none; border-radius: 8px; }
    .search-results { position: absolute; top: 100%; left: 0; right: 0; background: white; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); max-height: 200px; overflow-y: auto; z-index: 20; margin-top: 4px; }
    .search-result-item { padding: 12px 14px; cursor: pointer; border-bottom: 1px solid #eee; font-size: 0.95rem; }
    .search-result-item:last-child { border-bottom: none; }
    .search-result-item:hover { background: #f5f5f5; }
    .add-review-rating { display: flex; align-items: center; justify-content: space-between; padding: 16px; background: #ff8d00; color: white; border-radius: 8px; }
    .rating-hearts { display: flex; gap: 8px; }
    .heart { background: none; border: none; font-size: 1.8rem; cursor: pointer; opacity: 0.4; }
    .heart.active { opacity: 1; }
    .add-review-textarea { width: 100%; padding: 14px; font-size: 1rem; border: none; border-radius: 8px; min-height: 120px; resize: vertical; }
    .add-review-submit { padding: 16px; font-size: 1.2rem; font-weight: 600; background: white; color: #014288; border: 2px solid white; border-radius: 28px; cursor: pointer; }
    .add-review-cancel { margin-top: 12px; padding: 14px 24px; font-size: 1rem; background: transparent; color: white; border: 2px solid white; border-radius: 28px; cursor: pointer; width: 100%; }
    .add-review-meta { display: flex; gap: 12px; margin-bottom: 12px; }
    .add-review-photos { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 12px; }
    .photo-upload-btn { padding: 10px 16px; background: #f3f2ef; border-radius: 8px; cursor: pointer; font-size: 0.95rem; }
    .photo-add-sheet { position: relative; }
    .photo-add-sheet-backdrop { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.4); z-index: 199; }
    .photo-add-sheet-menu { display: none; position: absolute; left: 0; top: 100%; margin-top: 4px; background: white; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.15); padding: 8px; min-width: 220px; z-index: 200; }
    .photo-add-sheet-menu.show { display: block; }
    .photo-add-sheet-backdrop.show { display: block; }
    .photo-add-sheet-item { display: flex; align-items: center; gap: 12px; width: 100%; padding: 14px 16px; border: none; background: none; cursor: pointer; font-size: 1rem; text-align: left; border-radius: 8px; }
    .photo-add-sheet-item:hover { background: #f5f5f5; }
    .camera-modal-overlay { display: none; position: fixed; inset: 0; background: #000; z-index: 300; flex-direction: column; align-items: center; justify-content: center; }
    .camera-modal-overlay.show { display: flex; }
    .camera-modal-overlay video { max-width: 100%; max-height: 70vh; object-fit: contain; background: #111; }
    .camera-modal-overlay .camera-controls { display: flex; gap: 16px; margin-top: 16px; }
    .camera-modal-overlay .camera-btn { padding: 14px 28px; font-size: 1.1rem; border: none; border-radius: 28px; cursor: pointer; font-weight: 600; }
    .camera-capture-btn { background: #e31919; color: white; }
    .camera-close-btn { background: #333; color: white; }
    .camera-modal-overlay .camera-error { color: #fff; padding: 20px; text-align: center; }
    @media (max-width: 600px) {
      .photo-add-sheet-menu { position: fixed; left: 0; right: 0; bottom: 0; top: auto; margin: 0; border-radius: 16px 16px 0 0; padding-bottom: env(safe-area-inset-bottom, 0); max-height: 40vh; }
      .photo-add-sheet-menu .photo-add-sheet-item { padding: 16px 20px; font-size: 1.05rem; }
    }
    .photo-preview { position: relative; }
    .photo-preview img { width: 60px; height: 60px; object-fit: cover; border-radius: 8px; }
    .photo-preview button { position: absolute; top: -6px; right: -6px; width: 20px; height: 20px; border-radius: 50%; background: #e31919; color: white; border: none; cursor: pointer; font-size: 14px; line-height: 1; }
    .review-photos { display: flex; gap: 8px; margin-top: 8px; flex-wrap: wrap; }
    .review-photos img { width: 80px; height: 80px; object-fit: cover; border-radius: 8px; }
    .review-comments { padding: 8px 16px 12px 76px; border-top: 1px solid #f3f2ef; }
    .comment-item { font-size: 0.9rem; margin-bottom: 6px; }
    .comment-item strong { margin-right: 6px; }
    .comment-form { display: flex; gap: 8px; margin-top: 8px; }
    .comment-form input { flex: 1; padding: 8px 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 0.9rem; }
    .comment-form button { padding: 8px 16px; background: #0a66c2; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 0.9rem; }
    
    .map-filters { display: flex; flex-direction: column; gap: 4px; }
    .filter-btn { display: flex; justify-content: space-between; padding: 14px 16px; font-size: 1rem; border: none; color: white; text-align: left; width: 100%; cursor: pointer; }
    .filter-btn:nth-child(1) { background: #e31919; }
    .filter-btn:nth-child(2) { background: #7c4dff; }
    .filter-btn:nth-child(3) { background: #006CE0; }
    .filter-btn:nth-child(4) { background: #ff8d00; }
    .filter-active { box-shadow: inset 0 0 0 3px white; }
    #map-container { height: 600px; min-height: 500px; width: 100%; border-radius: 12px; overflow: hidden; position: relative; box-sizing: border-box; }
    #fix-location-map { height: 300px; min-height: 300px; width: 100%; border-radius: 12px; overflow: hidden; }
    .map-marker.leaflet-marker-icon { background: none !important; border: none !important; }
    .poi-tooltip { font-size: 0.85rem; white-space: nowrap; max-width: 200px; overflow: hidden; text-overflow: ellipsis; }
    .leaflet-top, .leaflet-left { transform: translate3d(0, 0, 0); -webkit-transform: translate3d(0, 0, 0); will-change: transform; }
    #map-container { transform: translateZ(0); -webkit-transform: translateZ(0); }
    .map-legend { display: flex; gap: 16px; margin-top: 8px; font-size: 0.85rem; color: #666; flex-wrap: wrap; }
    .map-controls { position: absolute; top: 12px; right: 12px; z-index: 500; display: flex; flex-direction: column; gap: 8px; }
    .map-control-btn { width: 40px; height: 40px; border-radius: 50%; background: white; border: none; box-shadow: 0 2px 8px rgba(0,0,0,0.2); cursor: pointer; font-size: 1.2rem; display: flex; align-items: center; justify-content: center; }
    .user-location-marker.leaflet-marker-icon { background: none !important; border: none !important; }
    .map-legend-dot { display: inline-block; width: 12px; height: 12px; border-radius: 50%; margin-right: 4px; vertical-align: middle; }
    
    .feed-search, .map-search { margin-bottom: 12px; }
    .feed-search input, .map-search input { width: 100%; padding: 12px 16px; font-size: 1rem; border: none; border-radius: 8px; }
    .feed-filters { display: flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap; }
    
    .list-toast { position: fixed; bottom: 24px; left: 50%; transform: translateX(-50%); background: #333; color: white; padding: 12px 20px; border-radius: 8px; font-size: 0.95rem; z-index: 9999; box-shadow: 0 4px 12px rgba(0,0,0,0.3); animation: listToastFade 2.5s ease forwards; }
    @keyframes listToastFade { 0%, 70% { opacity: 1; } 100% { opacity: 0; visibility: hidden; } }
    .list-trigger-btn { min-width: 44px; min-height: 44px; }
    .list-dropdown-menu { transition: transform 0.2s ease; }
    @media (max-width: 600px) {
      .list-dropdown-menu.show-mobile { position: fixed !important; left: 0 !important; right: 0 !important; bottom: 0 !important; top: auto !important; margin: 0 !important; max-height: 55vh !important; border-radius: 16px 16px 0 0 !important; z-index: 200 !important; padding-bottom: env(safe-area-inset-bottom, 0) !important; }
      .list-dropdown-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,0.4); z-index: 199; }
    }
    @media (max-width: 768px) {
      .ptr-indicator { top: 100px; }
      .app-content { padding-top: 100px; padding-left: 0; padding-right: 0; }
      .app-content-inner { max-width: 100%; width: 100%; padding: 0 10px; box-sizing: border-box; min-width: 0; }
      .app-content-inner.map-view, .app-content-inner.add-view { max-width: 100%; }
      .main { padding: 10px; max-width: 100%; }
      .header { padding: 8px 12px; }
      .header-logo { height: 28px; }
      .tabs { padding: 6px 2px; }
      .tab { padding: 6px 4px; font-size: 0.7rem; min-width: 0; }
      #map-container { height: 420px; min-height: 360px; }
      .feed-compose, .review-card { margin-bottom: 10px; }
      .review-card-header { padding: 10px 12px; }
      .review-avatar { width: 40px; height: 40px; font-size: 0.9rem; }
      .review-card-body { padding: 0 12px 10px 56px; }
      .review-actions { padding: 4px 12px 4px 56px; }
      .review-actions-secondary { padding: 4px 12px 6px 56px; }
      .add-review-rating { padding: 12px; }
      .add-review-input, .add-review-textarea, .feed-search input, .map-search input { font-size: 16px; }
    }
    .hidden { display: none !important; }
    .skip-link { position: absolute; top: -40px; left: 0; background: #e31919; color: white; padding: 8px 16px; z-index: 200; }
    .skip-link:focus { top: 0; }
    button:focus, input:focus, select:focus, textarea:focus { outline: 2px solid #e31919; outline-offset: 2px; }
  </style>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="">
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" crossorigin="">
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" crossorigin="">
</head>
<body>
  <a href="#main" class="skip-link">Skip to main content</a>
  <div id="chromeBanner" style="display:none;position:fixed;top:0;left:0;right:0;z-index:200;background:#1a73e8;color:white;padding:12px 16px;font-size:0.9rem;box-shadow:0 2px 8px rgba(0,0,0,0.2)">
    <div style="display:flex;align-items:center;justify-content:space-between;gap:12px;max-width:720px;margin:0 auto">
      <span>Open in Chrome for the best experience and to add to home screen</span>
      <a id="chromeBannerBtn" href="#" style="flex-shrink:0;padding:10px 16px;background:white;color:#1a73e8;border-radius:8px;font-weight:600;text-decoration:none;font-size:0.9rem">Open in Chrome</a>
    </div>
  </div>
  <div id="app" role="application" aria-label="Foodie app" style="min-height:200px;display:flex;align-items:center;justify-content:center;font-size:1.1rem;color:#666">Loading Foodie…</div>
  <noscript><div style="padding:24px;text-align:center">Please enable JavaScript to use Foodie.</div></noscript>
  <div id="cameraModal" class="camera-modal-overlay" aria-label="Camera capture" role="dialog">
    <video id="cameraVideo" autoplay playsinline muted></video>
    <div class="camera-controls">
      <button type="button" class="camera-btn camera-capture-btn" id="cameraCaptureBtn" onclick="captureFromCamera()">Capture</button>
      <button type="button" class="camera-btn camera-close-btn" onclick="closeCameraCapture()">Cancel</button>
    </div>
    <div id="cameraError" class="camera-error" style="display:none"></div>
  </div>
  <script src="config.js?v=9"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="foodie-api.js?v=9"></script>
  <script>
    function formatDate(ts) {
      const sec = (Date.now() - ts) / 1000, m = sec/60, h = m/60, d = h/24;
      if (sec < 45) return 'less than a minute ago';
      if (sec < 90) return 'about a minute ago';
      if (m < 45) return `about ${Math.round(m)} minutes ago`;
      if (m < 90) return 'about an hour ago';
      if (h < 24) return `about ${Math.round(h)} hours ago`;
      if (h < 42) return 'a day ago';
      if (d < 30) return `${Math.round(d)} days ago`;
      if (d < 45) return 'about a month ago';
      return `${Math.round(d/30)} months ago`;
    }

    const STORAGE_KEYS = {
      user: 'foodie_user', reviews: 'foodie_reviews', comments: 'foodie_comments',
      connections: 'foodie_connections', connectionRequests: 'foodie_connection_requests',
      saved: 'foodie_saved', notifications: 'foodie_notifications',
      profiles: 'foodie_profiles', privateNotes: 'foodie_private_notes',
      groupLists: 'foodie_group_lists', trustScores: 'foodie_trust_scores'
    };
    const GROUP_LIST_NAMES = ['Saved', 'Go-to spot', 'Date night', 'Family favorites', 'Work lunch', 'Quick bite'];
    const DEMO_USERS = ['Demo User', 'Kalyani', 'Yaugandha', 'Lavanya', 'Tom', 'Dick', 'Harry'];
    const CUISINES = ['Indian', 'Japanese', 'French', 'Italian', 'Mexican', 'American', 'Chinese', 'Korean', 'Thai', 'British', 'Nordic', 'Spanish', 'Peruvian', 'Australian', 'Various'];
    const PRICE_LABELS = ['$', '$$', '$$$', '$$$$'];
    const PHOTOS_BASE = 'photos/';
    const ALLOWED_IMAGE_TYPES = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
    const PHOTO_MAX_SIZE = 300000;
    const PHOTO_MAX_DIM = 2000;
    const NSFW_PORN_THRESHOLD = 0.5;
    const NSFW_HENTAI_THRESHOLD = 0.5;
    const NSFW_SEXY_THRESHOLD = 0.85;
    const MAX_REVIEW_TEXT = 2000;
    const MAX_DISPLAY_NAME = 50;
    const MAX_RESTAURANT_NAME = 100;
    const MAX_COMMENT_TEXT = 500;
    const DEFAULT_REVIEWS = [
      { id: 'k1', restaurant: 'Paradise Biryani, Pune', lat: 18.52, lng: 73.85, by: 'Kalyani', text: 'Amazing biryani! Authentic Hyderabad style.', rating: 5, date: Date.now() - 86400000*2, level: 1, likes: 4, liked: false, likedBy: ['Yaugandha','Lavanya','Tom','Dick'], cuisine: 'Indian', price: 2, photoFile: 'photo1.jpg', verifiedVisit: true, wouldGoAgain: true },
      { id: 'k2', restaurant: 'The Ivy, London', lat: 51.51, lng: -0.14, by: 'Kalyani', text: 'Classic British dining. The shepherd\'s pie is divine.', rating: 5, date: Date.now() - 86400000*5, level: 1, likes: 2, liked: false, cuisine: 'British', price: 4, photoFile: 'photo2.jpg' },
      { id: 'k3', restaurant: 'Sukiyabashi Jiro, Tokyo', lat: 35.66, lng: 139.73, by: 'Kalyani', text: 'Once in a lifetime sushi experience. Worth the wait.', rating: 5, date: Date.now() - 86400000*12, level: 2, likes: 8, liked: false, cuisine: 'Japanese', price: 4, photoFile: 'photo3.jpg' },
      { id: 'k4', restaurant: 'Café de Flore, Paris', lat: 48.85, lng: 2.33, by: 'Kalyani', text: 'Historic café with perfect croissants and people-watching.', rating: 4, date: Date.now() - 86400000*8, level: 1, likes: 3, liked: false },
      { id: 'k5', restaurant: 'Katz\'s Delicatessen, NYC', lat: 40.73, lng: -73.99, by: 'Kalyani', text: 'Best pastrami sandwich in the world. Huge portions!', rating: 5, date: Date.now() - 86400000*15, level: 2, likes: 5, liked: false },
      { id: 'k6', restaurant: 'Noma, Copenhagen', lat: 55.68, lng: 12.60, by: 'Kalyani', text: 'Innovative Nordic cuisine. Every course was a surprise.', rating: 5, date: Date.now() - 86400000*20, level: 1, likes: 6, liked: false },
      { id: 'k7', restaurant: 'El Celler de Can Roca, Girona', lat: 41.98, lng: 2.82, by: 'Kalyani', text: 'Molecular gastronomy at its finest. 14 courses of wonder.', rating: 5, date: Date.now() - 86400000*25, level: 2, likes: 2, liked: false },
      { id: 'k8', restaurant: 'Hawker Chan, Singapore', lat: 1.31, lng: 103.86, by: 'Kalyani', text: 'Michelin-starred chicken rice for under $5. Incredible.', rating: 5, date: Date.now() - 86400000*30, level: 1, likes: 7, liked: false },
      { id: 'k9', restaurant: 'Quay, Sydney', lat: -33.86, lng: 151.21, by: 'Kalyani', text: 'Stunning harbour views. The snow egg dessert is legendary.', rating: 5, date: Date.now() - 86400000*40, level: 2, likes: 4, liked: false },
      { id: 'k10', restaurant: 'Zuma, Dubai', lat: 25.08, lng: 55.14, by: 'Kalyani', text: 'Japanese izakaya in the desert. Great robata grill.', rating: 4, date: Date.now() - 86400000*45, level: 1, likes: 3, liked: false },
      { id: 'y1', restaurant: 'Saravana Bhavan, Chennai', lat: 13.08, lng: 80.27, by: 'Yaugandha', text: 'Best South Indian breakfast. Idlis are pillow-soft.', rating: 5, date: Date.now() - 86400000*1, level: 2, likes: 2, liked: false },
      { id: 'y2', restaurant: 'Dishoom, London', lat: 51.52, lng: -0.11, by: 'Yaugandha', text: 'Indian comfort food done right. Bacon naan is a must.', rating: 5, date: Date.now() - 86400000*4, level: 1, likes: 5, liked: false, likedBy: ['Kalyani','Lavanya','Harry','Tom','Dick'], photoFile: 'photo4.jpg', verifiedVisit: true, wouldGoAgain: true },
      { id: 'y3', restaurant: 'Osteria Francescana, Modena', lat: 44.65, lng: 10.93, by: 'Yaugandha', text: 'Bottura\'s genius. The famous pasta dish lives up to hype.', rating: 5, date: Date.now() - 86400000*7, level: 2, likes: 9, liked: false },
      { id: 'y4', restaurant: 'Pujol, Mexico City', lat: 19.43, lng: -99.19, by: 'Yaugandha', text: 'Modern Mexican. The 1,500-day mole is unforgettable.', rating: 5, date: Date.now() - 86400000*10, level: 1, likes: 4, liked: false },
      { id: 'y5', restaurant: 'Attica, Melbourne', lat: -37.87, lng: 144.97, by: 'Yaugandha', text: 'Australian bush tucker reimagined. Truly unique.', rating: 5, date: Date.now() - 86400000*14, level: 2, likes: 3, liked: false },
      { id: 'y6', restaurant: 'Central, Lima', lat: -12.09, lng: -77.03, by: 'Yaugandha', text: 'Altitude-based menu. Each course tells a story of Peru.', rating: 5, date: Date.now() - 86400000*18, level: 1, likes: 6, liked: false },
      { id: 'y7', restaurant: 'Gaggan, Bangkok', lat: 13.75, lng: 100.54, by: 'Yaugandha', text: 'Progressive Indian. Emoji menu was fun and delicious.', rating: 4, date: Date.now() - 86400000*22, level: 2, likes: 5, liked: false },
      { id: 'y8', restaurant: 'Le Bernardin, NYC', lat: 40.76, lng: -73.98, by: 'Yaugandha', text: 'Impeccable seafood. The Dover sole is perfection.', rating: 5, date: Date.now() - 86400000*28, level: 1, likes: 4, liked: false },
      { id: 'y9', restaurant: 'Mugaritz, San Sebastian', lat: 43.28, lng: -1.93, by: 'Yaugandha', text: 'Edible stones and philosophical cuisine. Mind-blowing.', rating: 5, date: Date.now() - 86400000*35, level: 2, likes: 2, liked: false },
      { id: 'y10', restaurant: 'Indian Accent, Delhi', lat: 28.61, lng: 77.22, by: 'Yaugandha', text: 'Indian flavors with global techniques. Blue cheese naan!', rating: 5, date: Date.now() - 86400000*42, level: 1, likes: 7, liked: false },
      { id: 'l1', restaurant: 'Trishna, Mumbai', lat: 18.93, lng: 72.83, by: 'Lavanya', text: 'Best butter garlic crab in the city. Messy but worth it.', rating: 5, date: Date.now() - 86400000*3, level: 1, likes: 6, liked: false, photoFile: 'photo5.jpg' },
      { id: 'l2', restaurant: 'The Fat Duck, Bray', lat: 51.51, lng: -0.70, by: 'Lavanya', text: 'Heston\'s theatrical dining. Snail porridge actually works!', rating: 5, date: Date.now() - 86400000*6, level: 2, likes: 8, liked: false },
      { id: 'l3', restaurant: 'Masa, NYC', lat: 40.77, lng: -73.98, by: 'Lavanya', text: 'Omakase at its peak. The toro was like butter.', rating: 5, date: Date.now() - 86400000*9, level: 1, likes: 4, liked: false },
      { id: 'l4', restaurant: 'Alinea, Chicago', lat: 41.91, lng: -87.65, by: 'Lavanya', text: 'Grant Achatz\'s edible balloon. Dining as art.', rating: 5, date: Date.now() - 86400000*11, level: 2, likes: 9, liked: false },
      { id: 'l5', restaurant: 'Dinner by Heston, London', lat: 51.51, lng: -0.14, by: 'Lavanya', text: 'Meat fruit and tipsy cake. Historical British cuisine.', rating: 5, date: Date.now() - 86400000*16, level: 1, likes: 5, liked: false },
      { id: 'l6', restaurant: 'Arpege, Paris', lat: 48.86, lng: 2.32, by: 'Lavanya', text: 'Alain Passard\'s vegetable garden. Vegetables never tasted so good.', rating: 5, date: Date.now() - 86400000*19, level: 2, likes: 3, liked: false },
      { id: 'l7', restaurant: 'Eleven Madison Park, NYC', lat: 40.74, lng: -73.99, by: 'Lavanya', text: 'Plant-based fine dining. Creative and sustainable.', rating: 4, date: Date.now() - 86400000*24, level: 1, likes: 4, liked: false },
      { id: 'l8', restaurant: 'Azurmendi, Bilbao', lat: 43.26, lng: -2.92, by: 'Lavanya', text: 'Farm-to-table in a glass cube. Stunning location.', rating: 5, date: Date.now() - 86400000*32, level: 2, likes: 2, liked: false },
      { id: 'l9', restaurant: 'Odette, Singapore', lat: 1.30, lng: 103.85, by: 'Lavanya', text: 'French cuisine in a museum. Elegant and refined.', rating: 5, date: Date.now() - 86400000*38, level: 1, likes: 6, liked: false },
      { id: 'l10', restaurant: 'Mingles, Seoul', lat: 37.52, lng: 127.03, by: 'Lavanya', text: 'Korean fine dining. Hanwoo beef was incredible.', rating: 5, date: Date.now() - 86400000*44, level: 2, likes: 4, liked: false },
      { id: 't1', restaurant: 'Franklin Barbecue, Austin', lat: 30.27, lng: -97.73, by: 'Tom', text: 'Worth the 4-hour queue. Best brisket in Texas.', rating: 5, date: Date.now() - 86400000*2, level: 2, likes: 7, liked: false },
      { id: 't2', restaurant: 'The Ledbury, London', lat: 51.52, lng: -0.20, by: 'Tom', text: 'Brett Graham\'s cooking. The venison is sublime.', rating: 5, date: Date.now() - 86400000*5, level: 1, likes: 3, liked: false },
      { id: 't3', restaurant: 'Saison, San Francisco', lat: 37.78, lng: -122.40, by: 'Tom', text: 'Fire and smoke. California meets Japan.', rating: 5, date: Date.now() - 86400000*8, level: 2, likes: 5, liked: false },
      { id: 't4', restaurant: 'Den, Tokyo', lat: 35.69, lng: 139.70, by: 'Tom', text: 'Dentucky Fried Chicken! Playful kaiseki.', rating: 5, date: Date.now() - 86400000*13, level: 1, likes: 8, liked: false },
      { id: 't5', restaurant: 'Septime, Paris', lat: 48.86, lng: 2.37, by: 'Tom', text: 'Natural wines and seasonal French. No reservations needed for bar.', rating: 4, date: Date.now() - 86400000*17, level: 2, likes: 4, liked: false },
      { id: 't6', restaurant: 'Single Thread, Healdsburg', lat: 38.61, lng: -122.87, by: 'Tom', text: 'Farm inn with incredible tasting menu. Romantic getaway.', rating: 5, date: Date.now() - 86400000*21, level: 1, likes: 3, liked: false },
      { id: 't7', restaurant: 'Core by Clare Smyth, London', lat: 51.51, lng: -0.18, by: 'Tom', text: 'First female 3-Michelin-star chef in UK. Potato and roe dish!', rating: 5, date: Date.now() - 86400000*26, level: 2, likes: 6, liked: false },
      { id: 't8', restaurant: 'Geranium, Copenhagen', lat: 55.69, lng: 12.57, by: 'Tom', text: 'Rasmus Kofoed\'s Nordic perfection. Views over the park.', rating: 5, date: Date.now() - 86400000*33, level: 1, likes: 5, liked: false },
      { id: 't9', restaurant: 'Maido, Lima', lat: -12.09, lng: -77.03, by: 'Tom', text: 'Nikkei cuisine. Japanese-Peruvian fusion at its best.', rating: 5, date: Date.now() - 86400000*39, level: 2, likes: 4, liked: false },
      { id: 't10', restaurant: 'The French Laundry, Yountville', lat: 38.40, lng: -122.36, by: 'Tom', text: 'Keller\'s iconic. The oyster and pearl lives up to legend.', rating: 5, date: Date.now() - 86400000*46, level: 1, likes: 9, liked: false },
      { id: 'd1', restaurant: 'Dishoom, London', lat: 51.52, lng: -0.11, by: 'Dick', text: 'Bombay café vibes. Black daal and chai are must-haves.', rating: 5, date: Date.now() - 86400000*1, level: 1, likes: 4, liked: false, likedBy: ['Kalyani','Yaugandha','Harry'], verifiedVisit: true, wouldGoAgain: true },
      { id: 'd2', restaurant: 'Joe\'s Stone Crab, Miami', lat: 25.77, lng: -80.13, by: 'Dick', text: 'Classic Miami. Stone crabs with mustard sauce.', rating: 5, date: Date.now() - 86400000*4, level: 2, likes: 5, liked: false },
      { id: 'd3', restaurant: 'L\'Astrance, Paris', lat: 48.86, lng: 2.28, by: 'Dick', text: 'Pascal Barbot\'s surprise menu. No menu, just trust.', rating: 5, date: Date.now() - 86400000*7, level: 1, likes: 3, liked: false },
      { id: 'd4', restaurant: 'Momofuku Ko, NYC', lat: 40.73, lng: -73.99, by: 'Dick', text: 'David Chang\'s counter experience. Shaved frozen foie gras.', rating: 5, date: Date.now() - 86400000*10, level: 2, likes: 6, liked: false },
      { id: 'd5', restaurant: 'Amber, Hong Kong', lat: 22.28, lng: 114.16, by: 'Dick', text: 'Richard Ekkebus\'s French-Asian. The wagyu is legendary.', rating: 5, date: Date.now() - 86400000*14, level: 1, likes: 7, liked: false },
      { id: 'd6', restaurant: 'Osteria Mozza, LA', lat: 34.10, lng: -118.33, by: 'Dick', text: 'Nancy Silverton\'s mozzarella bar. Burrata heaven.', rating: 5, date: Date.now() - 86400000*19, level: 2, likes: 4, liked: false },
      { id: 'd7', restaurant: 'Restaurant Gordon Ramsay, London', lat: 51.49, lng: -0.16, by: 'Dick', text: 'Three stars. The lobster ravioli is iconic.', rating: 5, date: Date.now() - 86400000*23, level: 1, likes: 5, liked: false },
      { id: 'd8', restaurant: 'Pujol, Mexico City', lat: 19.43, lng: -99.19, by: 'Dick', text: 'Enrique Olvera\'s mole madre. 1,500 days of flavor.', rating: 5, date: Date.now() - 86400000*29, level: 2, likes: 8, liked: false },
      { id: 'd9', restaurant: 'Narisawa, Tokyo', lat: 35.67, lng: 139.72, by: 'Dick', text: 'Satoyama cuisine. Forest on a plate.', rating: 5, date: Date.now() - 86400000*36, level: 1, likes: 4, liked: false },
      { id: 'd10', restaurant: 'El Celler de Can Roca', lat: 41.98, lng: 2.82, by: 'Dick', text: 'Roca brothers\' magic. The perfume dessert!', rating: 5, date: Date.now() - 86400000*43, level: 2, likes: 6, liked: false },
      { id: 'h1', restaurant: 'St John, London', lat: 51.52, lng: -0.10, by: 'Harry', text: 'Nose-to-tail dining. Roast bone marrow and parsley salad.', rating: 5, date: Date.now() - 86400000*2, level: 2, likes: 5, liked: false },
      { id: 'h2', restaurant: 'Sushi Saito, Tokyo', lat: 35.66, lng: 139.73, by: 'Harry', text: 'Impossible to book. But the sushi is transcendent.', rating: 5, date: Date.now() - 86400000*6, level: 1, likes: 7, liked: false },
      { id: 'h3', restaurant: 'Le Jules Verne, Paris', lat: 48.86, lng: 2.29, by: 'Harry', text: 'Dining in the Eiffel Tower. Views and Alain Ducasse.', rating: 4, date: Date.now() - 86400000*9, level: 2, likes: 4, liked: false },
      { id: 'h4', restaurant: 'The Clove Club, London', lat: 51.53, lng: -0.08, by: 'Harry', text: 'British ingredients, global techniques. Buttermilk fried chicken.', rating: 5, date: Date.now() - 86400000*13, level: 1, likes: 3, liked: false },
      { id: 'h5', restaurant: 'Cosme, NYC', lat: 40.74, lng: -73.99, by: 'Harry', text: 'Enrique Olvera in NYC. The husk meringue is iconic.', rating: 5, date: Date.now() - 86400000*16, level: 2, likes: 6, liked: false },
      { id: 'h6', restaurant: 'Mirazur, Menton', lat: 43.78, lng: 7.50, by: 'Harry', text: 'Mauro Colagreco\'s garden by the sea. World\'s best 2019.', rating: 5, date: Date.now() - 86400000*20, level: 1, likes: 8, liked: false },
      { id: 'h7', restaurant: 'Atomix, NYC', lat: 40.74, lng: -73.99, by: 'Harry', text: 'Korean tasting menu. Each course tells a story.', rating: 5, date: Date.now() - 86400000*27, level: 2, likes: 4, liked: false },
      { id: 'h8', restaurant: 'Asador Etxebarri, Axpe', lat: 43.11, lng: -2.60, by: 'Harry', text: 'Victor Arguinzoniz\'s grill. Everything cooked over fire.', rating: 5, date: Date.now() - 86400000*31, level: 1, likes: 5, liked: false },
      { id: 'h9', restaurant: 'Benu, San Francisco', lat: 37.78, lng: -122.40, by: 'Harry', text: 'Corey Lee\'s Asian-American. The thousand-year-old egg.', rating: 5, date: Date.now() - 86400000*37, level: 2, likes: 3, liked: false },
      { id: 'h10', restaurant: 'Gaggan Anand, Bangkok', lat: 13.75, lng: 100.54, by: 'Harry', text: 'Lick it up! Progressive Indian that changed the game.', rating: 5, date: Date.now() - 86400000*41, level: 1, likes: 9, liked: false }
    ];

    function loadFromStorage() {
      try {
        const user = localStorage.getItem(STORAGE_KEYS.user);
        let reviews = localStorage.getItem(STORAGE_KEYS.reviews);
        reviews = reviews ? JSON.parse(reviews) : DEFAULT_REVIEWS;
        reviews = reviews.map(r => ({ ...r, cuisine: r.cuisine || 'Various', price: r.price || 2, verifiedVisit: r.verifiedVisit || false, wouldGoAgain: r.wouldGoAgain !== false }));
        const comments = JSON.parse(localStorage.getItem(STORAGE_KEYS.comments) || '{}');
        const connections = JSON.parse(localStorage.getItem(STORAGE_KEYS.connections) || '{}');
        const connectionRequests = JSON.parse(localStorage.getItem(STORAGE_KEYS.connectionRequests) || '[]');
        const saved = JSON.parse(localStorage.getItem(STORAGE_KEYS.saved) || '[]');
        const notifications = JSON.parse(localStorage.getItem(STORAGE_KEYS.notifications) || '[]');
        const profiles = JSON.parse(localStorage.getItem(STORAGE_KEYS.profiles) || '{}');
        const privateNotes = JSON.parse(localStorage.getItem(STORAGE_KEYS.privateNotes) || '{}');
        const groupLists = JSON.parse(localStorage.getItem(STORAGE_KEYS.groupLists) || '{}');
        const trustScores = JSON.parse(localStorage.getItem(STORAGE_KEYS.trustScores) || '{}');
        return { user: user ? JSON.parse(user) : null, reviews, comments, connections, connectionRequests, saved, notifications, profiles, privateNotes, groupLists, trustScores };
      } catch (e) { return { user: null, reviews: DEFAULT_REVIEWS, comments: {}, connections: {}, connectionRequests: [], saved: [], notifications: [], profiles: {}, privateNotes: {}, groupLists: {}, trustScores: {} }; }
    }

    function saveToStorage() {
      if (window.FOODIE_API?.enabled) return;
      try {
        if (state.user) localStorage.setItem(STORAGE_KEYS.user, JSON.stringify(state.user));
        localStorage.setItem(STORAGE_KEYS.reviews, JSON.stringify(state.reviews));
        localStorage.setItem(STORAGE_KEYS.comments, JSON.stringify(state.comments));
        localStorage.setItem(STORAGE_KEYS.connections, JSON.stringify(state.connections));
        localStorage.setItem(STORAGE_KEYS.connectionRequests, JSON.stringify(state.connectionRequests));
        localStorage.setItem(STORAGE_KEYS.saved, JSON.stringify(state.saved));
        localStorage.setItem(STORAGE_KEYS.notifications, JSON.stringify(state.notifications));
        localStorage.setItem(STORAGE_KEYS.profiles, JSON.stringify(state.profiles));
        localStorage.setItem(STORAGE_KEYS.privateNotes, JSON.stringify(state.privateNotes));
        localStorage.setItem(STORAGE_KEYS.groupLists, JSON.stringify(state.groupLists));
        localStorage.setItem(STORAGE_KEYS.trustScores, JSON.stringify(state.trustScores));
      } catch (e) { console.warn('Storage save failed:', e); }
    }

    const state = {
      user: null,
      tab: 'feed',
      rating: 0,
      restaurantSearch: '',
      searchResults: [],
      selectedPlace: null,
      reviewText: '',
      reviews: [],
      comments: {},
      connections: {},
      connectionRequests: [],
      saved: [],
      notifications: [],
      profiles: {},
      privateNotes: {},
      groupLists: {},
      trustScores: {},
      feedSearch: '',
      mapSearch: '',
      menuOpen: false,
      panel: 'main',
      editingReview: null,
      mapFilter: 'all',
      feedCuisine: '',
      feedPrice: '',
      feedLevelFilter: '',
      feedMinRating: 0,
      viewRestaurant: null,
      commentInput: {},
      viewConnections: false,
      addConnectionInput: '',
      networkSearch: '',
      networkSearchResults: [],
      networkSearchLoading: false,
      suggestedUsers: [],
      suggestedUsersLoading: false,
      _suggestedUsersFetched: false,
      mapCuisine: '',
      mapPrice: '',
      mapMinRating: 0,
      userLocation: null,
      addCuisine: '',
      addPrice: 2,
      addPhotos: [],
      addVerifiedVisit: false,
      addWouldGoAgain: true,
      savedListFilter: 'Saved',
      mapFocusRestaurant: null,
      pickOnMapRestaurantName: null,
      pendingConnect: null,
      groups: [],
      pendingGroups: [],
      selectedGroupId: null,
      groupsPanel: 'list',
      createGroupName: '',
      createGroupMembers: [],
      authMode: 'signup',
      viewLikersReviewId: null,
      viewReviewersReviewId: null,
      fixLocationModal: null,
      _bootstrapComplete: false
    };
    async function bootstrapApp() {
      const hashParams = new URLSearchParams((location.hash || '').replace(/^#/, ''));
      if (hashParams.get('type') === 'recovery') {
        state.authMode = 'reset';
        state.user = null;
        state._bootstrapComplete = true;
        render();
        return;
      }
      if (window.FOODIE_API?.enabled && window.FOODIE_API.supabase) {
        await new Promise(function(resolve) {
          var done = false;
          function finish() { if (!done) { done = true; resolve(); } }
          var t = setTimeout(finish, 1500);
          try {
            var sub = window.FOODIE_API.supabase.auth.onAuthStateChange(function(ev, s) {
              if (ev === 'INITIAL_SESSION') { clearTimeout(t); if (sub && sub.unsubscribe) sub.unsubscribe(); finish(); }
            });
          } catch (e) { finish(); }
        });
      }
      var stored;
      if (window.FOODIE_API && window.FOODIE_API.enabled && window.FOODIE_API.loadData) {
        try {
          var loadPromise = window.FOODIE_API.loadData();
          var timeoutPromise = new Promise(function(_, reject) { setTimeout(function() { reject(new Error('Load timeout')); }, 5000); });
          stored = await Promise.race([loadPromise, timeoutPromise]);
        } catch (e) {
          console.warn('Foodie API load failed, using localStorage', e);
          stored = loadFromStorage();
        }
      } else {
        stored = loadFromStorage();
      }
      state.user = stored.user;
      state.reviews = stored.reviews || [];
      state.comments = stored.comments || {};
      state.connections = stored.connections || {};
      state.connectionRequests = stored.connectionRequests || [];
      state.saved = stored.saved || [];
      state.notifications = stored.notifications || [];
      state.profiles = stored.profiles || {};
      state.privateNotes = stored.privateNotes || {};
      state.groupLists = stored.groupLists || {};
      state.trustScores = stored.trustScores || {};
      state.groups = stored.groups || [];
      state._bootstrapComplete = true;
      render();
      handleDeepLink();
      setupAutoRefresh();
      setupChromeBanner();
      if (state.user && window.FOODIE_API?.enabled && (stored.groups || []).length === 0) {
        [1000, 2000, 4000].forEach(function(delay) {
          setTimeout(async function() {
            if ((state.groups || []).length > 0) return;
            try {
              const retry = await window.FOODIE_API.loadData();
              if ((retry.groups || []).length > 0) {
                state.groups = retry.groups || [];
                render();
              }
            } catch (e) {}
          }, delay);
        });
      }
    }

    async function refreshFeed() {
      if (!window.FOODIE_API?.enabled || !state.user) return;
      try {
        const stored = await window.FOODIE_API.loadData();
        state.reviews = stored.reviews || [];
        state.comments = stored.comments || {};
        state.connections = stored.connections || {};
        state.connectionRequests = stored.connectionRequests || [];
        state.saved = stored.saved || [];
        state.notifications = stored.notifications || [];
        state.profiles = stored.profiles || {};
        state.privateNotes = stored.privateNotes || {};
        state.groupLists = stored.groupLists || {};
        state.trustScores = stored.trustScores || {};
        state.groups = stored.groups || [];
        const serverIds = new Set((stored.groups || []).map(g => g.id));
        state.pendingGroups = (state.pendingGroups || []).filter(pg => {
          if (serverIds.has(pg.id)) return false;
          state.groups.push(pg);
          return true;
        });
        render();
        if ((stored.groups || []).length === 0 && !state._groupsRetryScheduled) {
          state._groupsRetryScheduled = true;
          [1500, 3000].forEach(function(delay) {
            setTimeout(async function() {
              if ((state.groups || []).length > 0) return;
              try {
                const retry = await window.FOODIE_API.loadData();
                if ((retry.groups || []).length > 0) {
                  state.groups = retry.groups || [];
                  render();
                }
              } catch (e) {}
              if (delay === 3000) state._groupsRetryScheduled = false;
            }, delay);
          });
        }
      } catch (e) { console.warn('Refresh failed', e); }
    }
    function setupAutoRefresh() {
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible' && state.user && window.FOODIE_API?.enabled) refreshFeed();
      });
      setInterval(() => {
        if (document.visibilityState === 'visible' && state.user && window.FOODIE_API?.enabled) refreshFeed();
      }, 60000);
      setupPullToRefresh();
    }
    function setupChromeBanner() {
      const ua = navigator.userAgent || '';
      const isAndroid = /Android/i.test(ua);
      const isWebView = /; wv\)/.test(ua);
      const isStandalone = window.matchMedia && window.matchMedia('(display-mode: standalone)').matches;
      if (!isAndroid || isStandalone) return;
      if (isWebView) {
        const banner = document.getElementById('chromeBanner');
        const btn = document.getElementById('chromeBannerBtn');
        if (!banner || !btn) return;
        const url = location.href;
        const withoutProtocol = url.replace(/^https?:\/\//, '');
        const intentUrl = 'intent://' + withoutProtocol + '#Intent;scheme=https;package=com.android.chrome;end';
        btn.href = intentUrl;
        btn.onclick = function(e) { e.preventDefault(); window.location.href = intentUrl; };
        banner.style.display = 'block';
        document.body.classList.add('chrome-banner-visible');
      }
    }
    let ptrStartY = 0, ptrPullAmount = 0, ptrActive = false;
    function setupPullToRefresh() {
      document.addEventListener('touchstart', function ptrTouchStart(e) {
        if (!state.user || !window.FOODIE_API?.enabled || document.getElementById('ptr-indicator') == null) return;
        if ((window.scrollY || document.documentElement.scrollTop) > 15) return;
        ptrStartY = e.touches[0].clientY;
        ptrPullAmount = 0;
        ptrActive = true;
      }, { passive: true });
      document.addEventListener('touchmove', function ptrTouchMove(e) {
        if (!ptrActive || !state.user || !window.FOODIE_API?.enabled) return;
        if ((window.scrollY || document.documentElement.scrollTop) > 15) { ptrActive = false; return; }
        const y = e.touches[0].clientY;
        const delta = y - ptrStartY;
        if (delta > 0) {
          ptrPullAmount = Math.min(delta * 0.6, 100);
          const ind = document.getElementById('ptr-indicator');
          const txt = ind?.querySelector('.ptr-text');
          if (ind) {
            ind.classList.add('visible');
            ind.style.transform = 'translateY(' + (ptrPullAmount - 56) + 'px)';
            if (txt) txt.textContent = ptrPullAmount >= 60 ? 'Release to refresh' : 'Pull to refresh';
          }
          if (ptrPullAmount > 70) e.preventDefault();
        }
      }, { passive: false });
      document.addEventListener('touchend', function ptrTouchEnd() {
        if (!ptrActive) return;
        const ind = document.getElementById('ptr-indicator');
        const txt = ind?.querySelector('.ptr-text');
        if (ptrPullAmount >= 60 && state.user && window.FOODIE_API?.enabled) {
          if (ind) { ind.classList.add('refreshing'); ind.style.transform = 'translateY(0)'; if (txt) txt.textContent = 'Refreshing...'; }
          refreshFeed().then(function() {}).finally(function() {
            ptrPullAmount = 0; ptrActive = false;
            const el = document.getElementById('ptr-indicator');
            if (el) { el.classList.remove('visible', 'refreshing'); el.style.transform = 'translateY(-100%)'; const t = el.querySelector('.ptr-text'); if (t) t.textContent = 'Pull to refresh'; }
          });
        } else {
          ptrPullAmount = 0; ptrActive = false;
          const el = document.getElementById('ptr-indicator');
          if (el) { el.classList.remove('visible', 'refreshing'); el.style.transform = 'translateY(-100%)'; const t = el.querySelector('.ptr-text'); if (t) t.textContent = 'Pull to refresh'; }
        }
      }, { passive: true });
    }

    let searchTimer = null;
    async function nominatimSearch(query, viewbox) {
      let url = 'https://nominatim.openstreetmap.org/search?format=json&q=' + encodeURIComponent(query) + '&limit=10';
      if (viewbox) url += '&viewbox=' + viewbox + '&bounded=1';
      const res = await fetch(url, { headers: { 'Accept': 'application/json', 'User-Agent': 'FoodieApp/1.0 (https://github.com/foodie-app; contact@foodie.app)' } });
      return res.json();
    }
    async function photonSearch(query, lat, lon, bbox) {
      let url = 'https://photon.komoot.io/api/?q=' + encodeURIComponent(query) + '&limit=10';
      if (lat != null && lon != null) url += '&lat=' + lat + '&lon=' + lon;
      if (bbox && bbox.minLon != null && bbox.minLat != null && bbox.maxLon != null && bbox.maxLat != null) url += '&bbox=' + bbox.minLon + ',' + bbox.minLat + ',' + bbox.maxLon + ',' + bbox.maxLat;
      const res = await fetch(url, { headers: { 'Accept': 'application/json' } });
      const data = await res.json();
      if (!data?.features?.length) return [];
      return data.features.map(f => {
        const p = f.properties || {};
        const coords = f.geometry?.coordinates || [];
        const lng = coords[0], lat = coords[1];
        const primary = p.name || p.street || p.locality || p.city || 'Place';
        const parts = [p.street, p.city, p.state].filter(Boolean);
        const extra = parts.filter(x => x !== primary).slice(0, 2).join(', ');
        const name = extra ? primary + ', ' + extra : primary;
        return { name, lat: parseFloat(lat), lng: parseFloat(lng) };
      });
    }

    function requestUserLocationIfNeeded(onGotLocation) {
      if (!navigator.geolocation) return;
      if (state.userLocation) { if (onGotLocation) onGotLocation(state.userLocation); return; }
      navigator.geolocation.getCurrentPosition(
        function(pos) {
          state.userLocation = { lat: pos.coords.latitude, lng: pos.coords.longitude };
          if (onGotLocation) onGotLocation(state.userLocation);
        },
        function() { if (onGotLocation) onGotLocation(null); },
        { enableHighAccuracy: false, timeout: 5000, maximumAge: 300000 }
      );
    }

    function queryLooksLikeDifferentLocation(q) {
      var trimmed = (q || '').trim();
      var commaIdx = trimmed.lastIndexOf(',');
      if (commaIdx < 0) return false;
      var afterComma = trimmed.slice(commaIdx + 1).trim();
      return afterComma.length >= 2 && !/^\d+/.test(afterComma);
    }

    function searchRestaurants(q) {
      state.restaurantSearch = q;
      if (q.length < 2) { state.searchResults = []; state.searchResultsFromCity = false; updateAddReviewSearchResults(); return; }
      clearTimeout(searchTimer);
      searchTimer = setTimeout(async () => {
        const loc = state.userLocation || { lat: 37.37, lng: -122.03 };
        try {
          let results = await photonSearch(q, loc.lat, loc.lng);
          if (!results.length) results = await photonSearch(q + ' restaurant', loc.lat, loc.lng);
          if (!results.length) {
            const data = await nominatimSearch(q);
            if (data?.length) results = data.map(p => ({ name: p.display_name, lat: parseFloat(p.lat), lng: parseFloat(p.lon) }));
          }
          if (!results.length) {
            const parts = q.split(',').map(p => p.trim()).filter(Boolean);
            const cityPart = parts.length >= 2 ? parts.slice(-2).join(', ') : (parts.length ? parts[0] : '');
            if (cityPart.length >= 3) {
              const cityResults = await photonSearch(cityPart, loc.lat, loc.lng);
              if (cityResults.length) {
                results = [{ name: q, lat: cityResults[0].lat, lng: cityResults[0].lng }];
                state.searchResultsFromCity = true;
              }
            }
            if (!results.length) {
              const alt = q.replace(/,/g, ' ').replace(/\s+/g, ' ').trim();
              if (alt !== q) results = await photonSearch(alt, loc.lat, loc.lng);
              if (!results.length && alt !== q) {
                const data = await nominatimSearch(alt);
                if (data?.length) results = data.map(p => ({ name: p.display_name, lat: parseFloat(p.lat), lng: parseFloat(p.lon) }));
              }
            }
            if (!results.length) {
              results = [{ name: q, lat: loc.lat, lng: loc.lng }];
              state.searchResultsFromCity = false;
            }
          } else state.searchResultsFromCity = false;
          state.searchResults = results.slice(0, 8);
        } catch (e) {
          state.searchResults = [{ name: q, lat: loc.lat, lng: loc.lng }];
          state.searchResultsFromCity = false;
        }
        updateAddReviewSearchResults();
      }, 400);
    }

    async function geocodePlaceOne(query, biasLat, biasLon, bbox) {
      let loc = (biasLat != null && biasLon != null) ? { lat: biasLat, lng: biasLon } : (state.userLocation || null);
      const results = await photonSearch(query, loc?.lat ?? null, loc?.lng ?? null, bbox);
      if (results.length > 0) return { lat: results[0].lat, lng: results[0].lng };
      const viewbox = bbox ? bbox.minLon + ',' + bbox.minLat + ',' + bbox.maxLon + ',' + bbox.maxLat : null;
      const data = await nominatimSearch(query, viewbox);
      if (data?.length) return { lat: parseFloat(data[0].lat), lng: parseFloat(data[0].lon) };
      return null;
    }
    async function reverseGeocode(lat, lng) {
      try {
        const url = 'https://nominatim.openstreetmap.org/reverse?lat=' + lat + '&lon=' + lng + '&format=json';
        const res = await fetch(url, { headers: { 'Accept': 'application/json', 'User-Agent': 'FoodieApp/1.0 (https://github.com/foodie-app; contact@foodie.app)' } });
        const data = await res.json();
        return data?.display_name || data?.name || 'Add location';
      } catch (e) { return 'Add location'; }
    }

    async function geocodePlace(query, biasLat, biasLon) {
      try {
        let loc = (biasLat != null && biasLon != null) ? { lat: biasLat, lng: biasLon } : (state.userLocation || null);
        let bbox = null;
        const parts = (query || '').split(',').map(p => p.trim()).filter(Boolean);
        const cityState = parts.length >= 2 ? parts.slice(-2).join(', ') : '';
        if (cityState.length >= 4) {
          const region = await photonSearch(cityState, null, null);
          if (region.length > 0) {
            const cityCenter = { lat: region[0].lat, lng: region[0].lng };
            const delta = 0.08;
            bbox = { minLon: cityCenter.lng - delta, minLat: cityCenter.lat - delta, maxLon: cityCenter.lng + delta, maxLat: cityCenter.lat + delta };
            loc = cityCenter;
          }
        } else if (loc) {
          const delta = 0.06;
          bbox = { minLon: loc.lng - delta, minLat: loc.lat - delta, maxLon: loc.lng + delta, maxLat: loc.lat + delta };
        }
        let r = await geocodePlaceOne(query, loc?.lat, loc?.lng, bbox);
        if (r) return r;
        if (bbox && !cityState && loc) return { lat: loc.lat, lng: loc.lng };
        if (bbox && parts.length > 2) {
          const simplified = parts[0] + ', ' + cityState;
          if (simplified !== query) r = await geocodePlaceOne(simplified, loc?.lat, loc?.lng, bbox);
          if (r) return r;
        }
        if (bbox && cityState) {
          const results = await photonSearch(query, loc?.lat ?? null, loc?.lng ?? null, null);
          if (results.length > 0 && loc) {
            const inRange = results.find(x => Math.abs(x.lat - loc.lat) < 0.15 && Math.abs(x.lng - loc.lng) < 0.15);
            if (inRange) return { lat: inRange.lat, lng: inRange.lng };
          }
        }
        r = await geocodePlaceOne(query, loc?.lat, loc?.lng, null);
        if (r) return r;
        if (loc) return { lat: loc.lat, lng: loc.lng };
      } catch (e) {}
      return null;
    }

    function updateAddReviewSearchResults() {
      const el = document.getElementById('addReviewSearchResults');
      if (!el) return;
      if (!state.searchResults.length) {
        el.innerHTML = '';
        el.style.display = 'none';
      } else {
        el.className = 'search-results';
        el.style.display = 'block';
        el.innerHTML = state.searchResults.map((p, i) =>
          `<div class="search-result-item" onclick="selectPlaceByIndex(${i})">${escapeHtml(p.name)}</div>`
        ).join('');
      }
    }

    function selectPlace(p) {
      state.selectedPlace = p;
      state.restaurantSearch = p.name;
      state.searchResults = [];
      render();
    }
    function selectPlaceByIndex(i) {
      if (state.searchResults[i]) selectPlace(state.searchResults[i]);
    }
    async function useTypedNameAsPlace() {
      const name = (document.getElementById('addReviewRestaurantInput')?.value || state.restaurantSearch || '').trim();
      if (!name) return;
      const loc = state.userLocation || { lat: 37.37, lng: -122.03 };
      const geocoded = await geocodePlace(name, loc.lat, loc.lng);
      if (geocoded) selectPlace({ name: name, lat: geocoded.lat, lng: geocoded.lng });
      else selectPlace({ name: name, lat: loc.lat, lng: loc.lng });
    }

    async function toggleLike(id) {
      const r = state.reviews.find(x => x.id === id);
      if (!r) return;
      const add = !r.liked;
      if (!r.likedBy) r.likedBy = [];
      if (add) {
        r.liked = true;
        r.likes = (r.likes||0) + 1;
        if (!r.likedBy.includes(state.user.displayName)) r.likedBy.push(state.user.displayName);
        if (r.by !== state.user.displayName) {
          state.notifications.push({ id: Date.now().toString(), type: 'like', text: `${state.user.displayName} liked your review of ${r.restaurant}`, read: false, date: Date.now() });
        }
      } else {
        r.liked = false;
        r.likes = Math.max(0, (r.likes||0) - 1);
        r.likedBy = (r.likedBy || []).filter(n => n !== state.user?.displayName);
      }
      if (window.FOODIE_API?.enabled) { try { await window.FOODIE_API.toggleLike(id, add); } catch (e) { console.warn(e); if (add) { r.liked = false; r.likes = Math.max(0, (r.likes||0) - 1); r.likedBy = (r.likedBy || []).filter(n => n !== state.user?.displayName); } else { r.liked = true; r.likes = (r.likes||0) + 1; if (!r.likedBy.includes(state.user?.displayName)) r.likedBy.push(state.user?.displayName); } } } else saveToStorage();
      render();
    }
    function showLikersModal(reviewId) {
      const r = state.reviews.find(x => x.id === reviewId);
      if (!r || !(r.likedBy || []).length) return;
      state.viewLikersReviewId = reviewId;
      render();
    }
    function closeLikersModal() {
      state.viewLikersReviewId = null;
      render();
    }

    function getComments(reviewId) {
      return (state.comments[reviewId] || []).slice();
    }
    async function addComment(reviewId, text) {
      const t = (text || '').trim().slice(0, MAX_COMMENT_TEXT);
      if (!t) return;
      if (!state.comments[reviewId]) state.comments[reviewId] = [];
      state.comments[reviewId].push({ id: Date.now().toString(), by: state.user.displayName, text: t, date: Date.now() });
      const r = state.reviews.find(x => x.id === reviewId);
      if (r && r.by !== state.user.displayName) {
        state.notifications.push({ id: Date.now().toString(), type: 'comment', text: `${state.user.displayName} commented on your review of ${r.restaurant}`, read: false, date: Date.now() });
      }
      if (window.FOODIE_API?.enabled) { try { await window.FOODIE_API.addComment(reviewId, t); } catch (e) { console.warn(e); } } else saveToStorage();
      render();
    }

    function shareReview(id) {
      const url = location.origin + location.pathname + (location.pathname.endsWith('/') ? '' : '/') + '?review=' + id;
      navigator.clipboard.writeText(url).then(() => alert('Link copied! Share it with friends.')).catch(() => prompt('Copy this link:', url));
    }

    async function shareApp(inviteMode) {
      const baseUrl = location.href.split('?')[0].replace(/\/index\.html$/i, '/');
      const appUrl = baseUrl + (state.user?.displayName ? '?connect=' + encodeURIComponent(state.user.displayName) : '');
      const name = state.user?.displayName || 'A friend';
      const shareText = inviteMode
        ? name + ' wants to connect with you on Foodie – restaurant reviews from people you trust. Open the link, sign up, then add to your home screen: iPhone: Share → Add to Home Screen; Android: open in Chrome, tap menu ⋮ → Install app or Add to Home screen.'
        : 'Check out Foodie – restaurant reviews from people you trust. Add to your home screen for the best experience: iPhone: Share → Add to Home Screen; Android: open in Chrome, tap menu ⋮ → Install app or Add to Home screen.';
      const message = shareText + ' ' + appUrl;
      closeMenu();
      try {
        if (navigator.share) {
          await navigator.share({
            title: inviteMode ? name + ' invited you to Foodie' : 'Foodie',
            text: shareText,
            url: appUrl
          });
          showListToast('Shared!');
        } else {
          throw new Error('Share not supported');
        }
      } catch (e) {
        if (e.name === 'AbortError') return;
        try {
          await navigator.clipboard.writeText(message);
          showListToast('Link copied! Paste and send to share.');
        } catch (e2) {
          showListToast('Copy this link: ' + appUrl);
          prompt('Copy this link:', appUrl);
        }
      }
    }

    function getSavedKey(r) { return (r.lat + ',' + r.lng + '|' + (r.restaurant||'')).slice(0,80); }
    function getAlsoReviewedBy(r) {
      if (!r) return [];
      return [...new Set(state.reviews.filter(x =>
        Math.abs(x.lat - r.lat) < 0.01 && Math.abs(x.lng - r.lng) < 0.01 && x.by !== r.by
      ).map(x => x.by))];
    }
    function getReviewsAtLocation(r) {
      if (!r) return [];
      return state.reviews.filter(x =>
        Math.abs(x.lat - r.lat) < 0.01 && Math.abs(x.lng - r.lng) < 0.01
      );
    }
    function isSaved(r) { return state.saved.includes(getSavedKey(r)); }
    function getPrivateNote(reviewId) { return (state.privateNotes || {})[reviewId] || ''; }
    async function setPrivateNote(reviewId, text) { if (!state.privateNotes) state.privateNotes = {}; state.privateNotes[reviewId] = (text || '').trim(); if (window.FOODIE_API?.enabled) { try { await window.FOODIE_API.setPrivateNote(reviewId, (text || '').trim()); } catch (e) { console.warn(e); } } else saveToStorage(); render(); }
    function getReviewListNames(r) {
      const k = getSavedKey(r);
      const names = [];
      if (state.saved.includes(k)) names.push('Saved');
      Object.keys(state.groupLists || {}).forEach(listName => { if ((state.groupLists[listName] || []).includes(k)) names.push(listName); });
      return names;
    }
    async function toggleSaveById(reviewId) {
      const r = state.reviews.find(x => x.id === reviewId);
      if (!r) return;
      const k = getSavedKey(r);
      const i = state.saved.indexOf(k);
      const add = i < 0;
      if (i >= 0) state.saved.splice(i, 1);
      else {
        state.saved.push(k);
        const myConns = state.connections[state.user?.displayName] || [];
        const connReviews = state.reviews.filter(x => myConns.includes(x.by) && Math.abs(x.lat - r.lat) < 0.01 && Math.abs(x.lng - r.lng) < 0.01 && x.by !== r.by);
        if (connReviews.length > 0) {
          const names = [...new Set(connReviews.map(x => x.by))].slice(0, 2).join(' and ');
          state.notifications.push({ id: Date.now().toString(), type: 'connection_reviewed_saved', text: `${names} reviewed ${r.restaurant} — you saved this place!`, read: false, date: Date.now() });
        }
      }
      if (window.FOODIE_API?.enabled) { try { await window.FOODIE_API.toggleSave(k, add); } catch (e) { console.warn(e); } } else saveToStorage();
      render();
    }
    function showListToast(msg) {
      const old = document.getElementById('listToast');
      if (old) old.remove();
      const el = document.createElement('div');
      el.id = 'listToast';
      el.className = 'list-toast';
      el.textContent = msg;
      document.body.appendChild(el);
      setTimeout(() => el.remove(), 2500);
    }
    async function addToList(reviewId, listName) {
      const r = state.reviews.find(x => x.id === reviewId);
      if (!r || !listName || listName === 'Saved') return;
      const k = getSavedKey(r);
      if (!state.groupLists[listName]) state.groupLists[listName] = [];
      if (!state.groupLists[listName].includes(k)) state.groupLists[listName].push(k);
      try {
        if (window.FOODIE_API?.enabled) await window.FOODIE_API.toggleList(listName, k, true);
        else saveToStorage();
        showListToast('Added to ' + listName);
      } catch (e) {
        console.warn(e);
        const idx = (state.groupLists[listName] || []).indexOf(k);
        if (idx >= 0) state.groupLists[listName].splice(idx, 1);
        showListToast('Could not save. Try again.');
      }
      render();
    }
    async function removeFromList(reviewId, listName) {
      const r = state.reviews.find(x => x.id === reviewId);
      if (!r) return;
      const k = getSavedKey(r);
      const hadInSaved = state.saved.includes(k);
      const hadInList = (state.groupLists[listName] || []).includes(k);
      if (listName === 'Saved') { const i = state.saved.indexOf(k); if (i >= 0) state.saved.splice(i, 1); }
      else if (state.groupLists[listName]) { const arr = state.groupLists[listName]; const i = arr.indexOf(k); if (i >= 0) arr.splice(i, 1); }
      try {
        if (window.FOODIE_API?.enabled) { if (listName === 'Saved') await window.FOODIE_API.toggleSave(k, false); else await window.FOODIE_API.toggleList(listName, k, false); }
        else saveToStorage();
        showListToast('Removed from ' + listName);
      } catch (e) {
        console.warn(e);
        if (listName === 'Saved' && hadInSaved) state.saved.push(k);
        else if (hadInList && state.groupLists[listName]) state.groupLists[listName].push(k);
        showListToast('Could not remove. Try again.');
      }
      render();
    }
    async function toggleList(reviewId, listName) {
      const r = state.reviews.find(x => x.id === reviewId);
      if (!r || !listName) return;
      const k = getSavedKey(r);
      const inList = (state.groupLists[listName] || []).includes(k);
      if (inList) await removeFromList(reviewId, listName);
      else await addToList(reviewId, listName);
    }
    function toggleListDropdown(ev, btn) {
      if (ev) { ev.stopPropagation(); }
      const w = btn.closest('.review-list-dropdown');
      if (!w) return;
      const m = w.querySelector('.list-dropdown-menu');
      const b = w.querySelector('.list-dropdown-backdrop');
      const open = m && m.style.display === 'block';
      if (m) { m.style.display = open ? 'none' : 'block'; m.classList.toggle('show-mobile', !open); }
      if (b) b.style.display = open ? 'none' : 'block';
    }

    function viewRestaurantDetail(restaurant, lat, lng) {
      goToRestaurantOnMap(restaurant, lat, lng);
    }
    async function viewRestaurantFromReviewId(reviewId) {
      const r = state.reviews.find(x => x.id === reviewId);
      if (!r) return;
      let la = parseFloat(r.lat), ln = parseFloat(r.lng);
      const invalid = isNaN(la) || isNaN(ln) || la < -90 || la > 90 || ln < -180 || ln > 180;
      const looksDefault = (la === 0 && ln === 0) || (Math.abs(la - 37.37) < 0.1 && Math.abs(ln - (-122.03)) < 0.1);
      const outsideIndia = la < 8 || la > 35 || ln < 68 || ln > 97;
      const name = (r.restaurant || '').trim();
      const suggestsIndia = name.length > 3 && /india|thane|mumbai|delhi|bangalore|chennai|pune|hyderabad|kolkata/i.test(name);
      if (invalid && suggestsIndia && name.length > 5) {
        const geocoded = await geocodePlace(name, 20, 77);
        if (geocoded) { la = geocoded.lat; ln = geocoded.lng; goToRestaurantOnMap(r.restaurant, la, ln); return; }
      }
      if (invalid) {
        showListToast('Location not set for this review. Tap Fix location to add it.');
        openFixLocationModal(r.restaurant || '', 0, 0, r.id);
        return;
      }
      if (suggestsIndia && name.length > 5 && (looksDefault || outsideIndia)) {
        const geocoded = await geocodePlace(name, 20, 77);
        if (geocoded) { la = geocoded.lat; ln = geocoded.lng; }
      }
      goToRestaurantOnMap(r.restaurant, la, ln);
    }
    function goToRestaurantOnMap(name, lat, lng) {
      const la = parseFloat(lat), ln = parseFloat(lng);
      if (isNaN(la) || isNaN(ln) || la < -90 || la > 90 || ln < -180 || ln > 180) return;
      state.viewRestaurant = { name: name || '', lat: la, lng: ln };
      state.mapFocusRestaurant = { name: name || '', lat: la, lng: ln };
      state.tab = 'map';
      state.panel = 'main';
      render();
    }
    function viewRestaurantReviews(restaurant, lat, lng) {
      const la = parseFloat(lat), ln = parseFloat(lng);
      if (isNaN(la) || isNaN(ln)) return;
      state.viewRestaurant = { name: restaurant, lat: la, lng: ln };
      state.panel = 'restaurant';
      render();
    }
    function showRestaurantOnMap(name, lat, lng) {
      goToRestaurantOnMap(name, lat, lng);
    }
    function goToMapFromViewRestaurant() {
      const vr = state.viewRestaurant;
      if (vr) goToRestaurantOnMap(vr.name, vr.lat, vr.lng);
    }
    async function openFixLocationModal(restaurantName, oldLat, oldLng, reviewId) {
      let lat = typeof oldLat === 'number' && !isNaN(oldLat) ? oldLat : 0;
      let lng = typeof oldLng === 'number' && !isNaN(oldLng) ? oldLng : 0;
      let pinLat = (lat === 0 && lng === 0) ? 20 : lat;
      let pinLng = (lat === 0 && lng === 0) ? 77 : lng;
      const name = (restaurantName || '').trim();
      const suggestsIndia = name.length > 3 && /india|thane|mumbai|delhi|bangalore|chennai|pune|hyderabad|kolkata/i.test(name);
      const looksDefault = (lat === 0 && lng === 0) || (Math.abs(lat - 37.37) < 0.1 && Math.abs(lng - (-122.03)) < 0.1);
      const outsideIndia = lat < 8 || lat > 35 || lng < 68 || lng > 97;
      if (suggestsIndia && name.length > 5 && (looksDefault || outsideIndia)) {
        const geocoded = await geocodePlace(name, 20, 77);
        if (geocoded) { pinLat = geocoded.lat; pinLng = geocoded.lng; }
      }
      state.fixLocationModal = { restaurantName, oldLat: lat, oldLng: lng, pinLat, pinLng, reviewId: reviewId || null };
      render();
      setTimeout(initFixLocationMap, 250);
    }
    function closeFixLocationModal() {
      state.fixLocationModal = null;
      if (fixLocationMap) { try { fixLocationMap.remove(); } catch (e) {} fixLocationMap = null; }
      render();
    }
    let fixLocationMap = null;
    let fixLocationMarker = null;
    function initFixLocationMap() {
      const m = state.fixLocationModal;
      if (!m || !document.getElementById('fix-location-map') || typeof L === 'undefined') return;
      try { if (fixLocationMap) fixLocationMap.remove(); } catch (e) {}
      fixLocationMap = L.map('fix-location-map', { minZoom: 1, maxZoom: 19 }).setView([m.pinLat, m.pinLng], 14);
      L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager_labels_under/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap &copy; CARTO', subdomains: 'abcd', maxZoom: 20 }).addTo(fixLocationMap);
      fixLocationMarker = L.marker([m.pinLat, m.pinLng], { draggable: true }).addTo(fixLocationMap);
      fixLocationMarker.on('dragend', function() {
        const pos = fixLocationMarker.getLatLng();
        state.fixLocationModal.pinLat = pos.lat;
        state.fixLocationModal.pinLng = pos.lng;
      });
      fixLocationMap.on('click', function(e) {
        fixLocationMarker.setLatLng(e.latlng);
        state.fixLocationModal.pinLat = e.latlng.lat;
        state.fixLocationModal.pinLng = e.latlng.lng;
      });
      [350, 600].forEach(d => setTimeout(function() { try { if (fixLocationMap) fixLocationMap.invalidateSize(); } catch(e) {} }, d));
    }
    async function confirmFixLocationPin() {
      const m = state.fixLocationModal;
      if (!m) return;
      const { restaurantName, oldLat, oldLng, pinLat, pinLng, reviewId } = m;
      let toUpdate = reviewId ? state.reviews.filter(r => r.id === reviewId) : state.reviews.filter(r => {
        const rlat = parseFloat(r.lat), rlng = parseFloat(r.lng);
        if (isNaN(rlat) || isNaN(rlng)) return (oldLat === 0 && oldLng === 0) && (r.restaurant || '').trim() === (restaurantName || '').trim();
        return Math.abs(rlat - oldLat) < 0.01 && Math.abs(rlng - oldLng) < 0.01;
      });
      for (const r of toUpdate) {
        r.lat = pinLat; r.lng = pinLng;
        if (window.FOODIE_API?.enabled) {
          try {
            await window.FOODIE_API.fixReviewLocation(r.id, pinLat, pinLng);
          } catch (e) {
            console.warn(e);
            try { await window.FOODIE_API.saveReview(r); } catch (e2) { console.warn(e2); }
          }
        }
      }
      if (!window.FOODIE_API?.enabled) saveToStorage();
      if (state.viewRestaurant && Math.abs(state.viewRestaurant.lat - oldLat) < 0.01 && Math.abs(state.viewRestaurant.lng - oldLng) < 0.01) state.viewRestaurant = { ...state.viewRestaurant, lat: pinLat, lng: pinLng };
      state.mapFocusRestaurant = state.mapFocusRestaurant && Math.abs(state.mapFocusRestaurant.lat - oldLat) < 0.01 ? { ...state.mapFocusRestaurant, lat: pinLat, lng: pinLng } : state.mapFocusRestaurant;
      closeFixLocationModal();
      render();
      if (state.tab === 'map') setTimeout(initMap, 50);
    }
    async function fixLocationForRestaurant(restaurantName, oldLat, oldLng, reviewId) {
      openFixLocationModal(restaurantName, oldLat, oldLng, reviewId);
    }

    async function connectFromSearch(displayName) {
      await sendConnectionRequest(displayName);
      state.networkSearch = ''; state.networkSearchResults = [];
      const el = document.getElementById('networkSearchInput');
      if (el) el.value = '';
      if (window.FOODIE_API?.enabled) await refreshFeed(); else render();
    }
    async function sendConnectionRequest(toName) {
      if (!toName || !toName.trim()) return;
      const from = state.user.displayName;
      const to = toName.trim();
      if (state.pendingConnect && state.pendingConnect.trim().toLowerCase() === to.toLowerCase()) { state.pendingConnect = null; try { localStorage.removeItem('foodie_pendingConnect'); } catch(e) {} }
      if (from === to) return;
      const conns = state.connections[from] || [];
      if (conns.includes(to)) return;
      const reqs = state.connectionRequests || [];
      if (reqs.some(r => r.from === from && r.to === to && r.status === 'pending')) return;
      if (reqs.some(r => r.from === to && r.to === from && r.status === 'pending')) return;
      const reqId = Date.now().toString();
      reqs.push({ id: reqId, from, to, status: 'pending', date: Date.now() });
      state.connectionRequests = reqs;
      state.notifications.push({ id: Date.now().toString(), type: 'request', text: `Connection request sent to ${to}. They'll need to approve.`, read: false, date: Date.now() });
      state.notifications.push({ id: Date.now().toString(), type: 'connection_request', text: `${from} wants to connect with you`, read: false, date: Date.now(), recipient: to });
      state.suggestedUsers = (state.suggestedUsers || []).filter(p => p.displayName !== to);
      if (window.FOODIE_API?.enabled) { try { await window.FOODIE_API.sendConnectionRequest(to, reqId); } catch (e) { console.warn(e); } } else saveToStorage();
      render();
    }
    async function acceptConnectionRequest(reqId) {
      const req = (state.connectionRequests || []).find(r => r.id === reqId && r.to === state.user.displayName && r.status === 'pending');
      if (!req) return;
      req.status = 'accepted';
      const from = req.from, to = req.to;
      if (!state.connections[from]) state.connections[from] = [];
      if (!state.connections[from].includes(to)) state.connections[from].push(to);
      if (!state.connections[to]) state.connections[to] = [];
      if (!state.connections[to].includes(from)) state.connections[to].push(from);
      state.notifications.push({ id: Date.now().toString(), type: 'connection', text: `You and ${from} are now connected.`, read: false, date: Date.now() });
      if (window.FOODIE_API?.enabled) { try { await window.FOODIE_API.acceptConnectionRequest(reqId); } catch (e) { console.warn(e); } } else saveToStorage();
      render();
    }
    async function ignoreConnectionRequest(reqId) {
      const req = (state.connectionRequests || []).find(r => r.id === reqId && r.to === state.user.displayName);
      if (req) { req.status = 'ignored'; if (window.FOODIE_API?.enabled) { try { await window.FOODIE_API.ignoreConnectionRequest(reqId); } catch (e) { console.warn(e); } } else saveToStorage(); render(); }
    }
    async function cancelConnectionRequest(reqId) {
      const req = (state.connectionRequests || []).find(r => r.id === reqId && r.from === state.user?.displayName && r.status === 'pending');
      if (!req) return;
      req.status = 'cancelled';
      if (window.FOODIE_API?.enabled) { try { await window.FOODIE_API.cancelConnectionRequest(reqId); } catch (e) { console.warn(e); } } else saveToStorage();
      render();
    }
    async function removeConnection(name) {
      const uid = state.user.displayName;
      if (state.connections[uid]) {
        state.connections[uid] = state.connections[uid].filter(c => c !== name);
        if (state.connections[name]) state.connections[name] = state.connections[name].filter(c => c !== uid);
        if (window.FOODIE_API?.enabled) { try { await window.FOODIE_API.removeConnection(name); } catch (e) { console.warn(e); } } else saveToStorage();
        render();
      }
    }
    function normalizeGroupName(s) {
      return (s || '').trim().replace(/\s+/g, ' ');
    }
    async function createGroup() {
      const raw = (document.getElementById('createGroupNameInput')?.value || state.createGroupName || '').trim();
      const name = normalizeGroupName(raw);
      if (!name) { alert('Enter a group name'); return; }
      const existing = (state.groups || []).concat(state.pendingGroups || []).find(g => normalizeGroupName(g.name).toLowerCase() === name.toLowerCase());
      if (existing) { alert('You already have a group named "' + existing.name + '". Use a different name.'); return; }
      const api = window.FOODIE_API;
      if (!api?.enabled) return;
      try {
        const id = await api.createGroup(name);
        for (const m of (state.createGroupMembers || [])) {
          try { await api.addGroupMemberByName(id, m); } catch (e) { console.warn('Could not add', m, e); }
        }
        const memberNames = [state.user.displayName, ...(state.createGroupMembers || [])];
        const newGroup = { id, name, createdBy: state.user.displayName, memberNames };
        state.pendingGroups = state.pendingGroups || [];
        state.pendingGroups.push(newGroup);
        state.groups = state.groups || [];
        state.groups.push(newGroup);
        state.groupsPanel = 'detail'; state.selectedGroupId = id; state.createGroupName = ''; state.createGroupMembers = [];
        render();
        refreshFeed().then(() => render());
      } catch (e) { alert(e.message || 'Could not create group'); }
    }
    async function addMemberToGroup(groupId, displayName) {
      try {
        await window.FOODIE_API.addGroupMemberByName(groupId, displayName);
        await refreshFeed();
        render();
      } catch (e) { alert(e.message || 'Could not add member'); }
    }
    async function removeMemberFromGroup(groupId, displayName) {
      if (!confirm('Remove ' + displayName + ' from this group?')) return;
      try {
        const userId = await window.FOODIE_API.getUserIdByDisplayName(displayName);
        if (userId) await window.FOODIE_API.removeGroupMember(groupId, userId);
        await refreshFeed();
        render();
      } catch (e) { alert(e.message || 'Could not remove member'); }
    }
    async function deleteGroupConfirm(groupId) {
      if (!confirm('Delete this group? This cannot be undone.')) return;
      try {
        await window.FOODIE_API.deleteGroup(groupId);
        await refreshFeed();
        state.groupsPanel = 'list'; state.selectedGroupId = null;
        render();
      } catch (e) { alert(e.message || 'Could not delete group'); }
    }
    async function leaveGroupConfirm(groupId) {
      if (!confirm('Leave this group?')) return;
      try {
        await window.FOODIE_API.leaveGroup(groupId);
        await refreshFeed();
        state.groupsPanel = 'list'; state.selectedGroupId = null;
        render();
      } catch (e) { alert(e.message || 'Could not leave group'); }
    }
    function getPeopleYouCanAdd() {
      const me = state.user?.displayName;
      if (!me) return [];
      const fromReviews = [...new Set((state.reviews || []).map(r => r.by).filter(Boolean))];
      const allUsers = fromReviews.filter(u => !DEMO_USERS.includes(u));
      const conns = state.connections[me] || [];
      const reqs = state.connectionRequests || [];
      const pendingFromMe = reqs.filter(r => r.from === me && r.status === 'pending').map(r => r.to);
      return allUsers.filter(u => u !== me && !conns.includes(u) && !pendingFromMe.includes(u));
    }
    function getPeopleYouMightKnow() {
      const me = state.user?.displayName;
      if (!me) return [];
      const myConns = state.connections[me] || [];
      const pendingFromMe = (state.connectionRequests || []).filter(r => r.from === me && r.status === 'pending').map(r => r.to);
      const suggestions = [];
      const mutualCount = {};
      myConns.forEach(friend => {
        const friendsOfFriend = state.connections[friend] || [];
        friendsOfFriend.forEach(person => {
          if (person === me || myConns.includes(person) || pendingFromMe.includes(person) || DEMO_USERS.includes(person)) return;
          if (!suggestions.includes(person)) suggestions.push(person);
          mutualCount[person] = (mutualCount[person] || 0) + 1;
        });
      });
      return suggestions.map(name => ({ name, mutual: mutualCount[name] || 0 })).sort((a, b) => b.mutual - a.mutual);
    }
    function getPendingRequestsFromMe() {
      return (state.connectionRequests || []).filter(r => r.from === state.user?.displayName && r.status === 'pending');
    }
    function getPendingRequestsForMe() {
      return (state.connectionRequests || []).filter(r => r.to === state.user?.displayName && r.status === 'pending');
    }
    function canConnectWith(name) {
      if (!name || !state.user) return false;
      if (name === state.user.displayName) return false;
      const conns = state.connections[state.user.displayName] || [];
      if (conns.includes(name)) return false;
      return true;
    }
    function hasPendingRequestTo(name) {
      return (state.connectionRequests || []).some(r => r.from === state.user?.displayName && r.to === name && r.status === 'pending');
    }
    let networkSearchTimer = null;
    async function runNetworkSearch() {
      const q = (state.networkSearch || '').trim();
      if (q.length < 2 || !window.FOODIE_API?.enabled) { state.networkSearchResults = []; state.networkSearchLoading = false; render(); return; }
      state.networkSearchLoading = true;
      render();
      try {
        const results = await window.FOODIE_API.searchProfiles(q);
        const me = state.user?.displayName;
        const conns = state.connections[me] || [];
        const pendingFromMe = (state.connectionRequests || []).filter(r => r.from === me && r.status === 'pending').map(r => r.to);
        state.networkSearchResults = (results || []).filter(p => p.displayName !== me && !conns.includes(p.displayName) && !pendingFromMe.includes(p.displayName) && !DEMO_USERS.includes(p.displayName));
      } catch (e) { state.networkSearchResults = []; }
      state.networkSearchLoading = false;
      render();
    }
    function onNetworkSearchInput() {
      state.networkSearch = document.getElementById('networkSearchInput')?.value || '';
      clearTimeout(networkSearchTimer);
      if ((state.networkSearch || '').trim().length < 2) { state.networkSearchResults = []; state.networkSearchLoading = false; return; }
      state.networkSearchLoading = true;
      networkSearchTimer = setTimeout(runNetworkSearch, 350);
      render();
    }
    async function loadSuggestedUsers() {
      if (!window.FOODIE_API?.enabled || !window.FOODIE_API.getSuggestedUsers) return;
      state.suggestedUsersLoading = true;
      state._suggestedUsersFetched = true;
      render();
      try {
        const results = await window.FOODIE_API.getSuggestedUsers();
        const me = state.user?.displayName;
        const conns = state.connections[me] || [];
        const pendingFromMe = (state.connectionRequests || []).filter(r => r.from === me && r.status === 'pending').map(r => r.to);
        state.suggestedUsers = (results || []).filter(p => p.displayName !== me && !conns.includes(p.displayName) && !pendingFromMe.includes(p.displayName) && !DEMO_USERS.includes(p.displayName));
      } catch (e) { state.suggestedUsers = []; }
      state.suggestedUsersLoading = false;
      render();
    }

    function isSafePhotoUrl(url) {
      if (!url || typeof url !== 'string') return false;
      const u = url.trim();
      if (u.startsWith('data:image/')) {
        const m = u.match(/^data:(image\/(jpeg|png|gif|webp));base64,/i);
        return !!m;
      }
      if (u.startsWith(PHOTOS_BASE) && /^photos\/[a-zA-Z0-9_.-]+\.(jpg|jpeg|png|gif|webp)$/i.test(u)) return true;
      return false;
    }
    function getSafeAvatarUrl(prof) {
      const url = prof?.avatar;
      return url && isSafePhotoUrl(url) ? url : '';
    }
    function escapeHtml(s) {
      if (s == null || s === '') return '';
      const t = String(s);
      return t.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');
    }
    function getInitials(name) {
      return (name || '?').split(' ').map(n => n[0]).join('').toUpperCase().slice(0, 2);
    }

    function getReviewPhotoUrls(r) {
      if (r.photos && r.photos.length > 0) return r.photos.filter(isSafePhotoUrl);
      if (r.photoFile) {
        const u = PHOTOS_BASE + r.photoFile;
        return isSafePhotoUrl(u) ? [u] : [];
      }
      return [];
    }

    function getConnectionLabel(level, r) {
      if (r?.seed) return 'Discover';
      if (level === 1) return '1st';
      if (level === 2) return '2nd';
      return 'You';
    }
    function getMutualConnectionsCount(r) {
      if (!state.user || !r) return 0;
      const myConns = state.connections[state.user.displayName] || [];
      const samePlace = state.reviews.filter(x => Math.abs(x.lat - r.lat) < 0.01 && Math.abs(x.lng - r.lng) < 0.01 && x.by !== r.by);
      return samePlace.filter(x => myConns.includes(x.by)).length;
    }
    function getTrustScore(name) {
      if (!state.user || !name || name === state.user.displayName) return null;
      const cached = state.trustScores[name];
      if (cached !== undefined) return cached;
      const myReviews = state.reviews.filter(r => r.by === state.user.displayName);
      const theirReviews = state.reviews.filter(r => r.by === name);
      const overlap = myReviews.filter(m => theirReviews.some(t => Math.abs(m.lat - t.lat) < 0.01 && Math.abs(m.lng - t.lng) < 0.01));
      if (overlap.length === 0) return 75;
      const match = overlap.filter(p => {
        const theirs = theirReviews.find(t => Math.abs(p.lat - t.lat) < 0.01 && Math.abs(p.lng - t.lng) < 0.01);
        return theirs && Math.abs((p.rating||0) - (theirs.rating||0)) <= 1;
      }).length;
      return Math.round(50 + (match / Math.max(1, overlap.length)) * 50);
    }
    function getEffectiveLevel(r) {
      if (!r || !state.user) return 2;
      if (r.seed) return 0;
      if (r.userId === state.user.id || (r.by || '').trim().toLowerCase() === (state.user.displayName || '').trim().toLowerCase()) return 3;
      const myConns = state.connections[state.user.displayName] || [];
      if (myConns.includes(r.by)) return 1;
      if (myConns.some(c => (state.connections[c] || []).includes(r.by))) return 2;
      return 2;
    }

    function editReviewById(id) {
      const review = state.reviews.find(r => r.id === id);
      if (review) editReview(review);
    }
    function editReview(review) {
      state.editingReview = review;
      state.restaurantSearch = review.restaurant;
      state.selectedPlace = { name: review.restaurant, lat: review.lat, lng: review.lng };
      state.rating = review.rating;
      state.reviewText = review.text;
      state.addCuisine = review.cuisine || '';
      state.addPrice = review.price || 2;
      state.addPhotos = (review.photos || []).slice();
      state.addVerifiedVisit = !!review.verifiedVisit;
      state.addWouldGoAgain = review.wouldGoAgain !== false;
      state.searchResults = [];
      setTab('add');
    }

    function cancelEdit() { discardReview(); }
    function discardReview() {
      state.editingReview = null;
      state.pickOnMapRestaurantName = null;
      state.rating = 0;
      state.reviewText = '';
      state.restaurantSearch = '';
      state.selectedPlace = null;
      state.searchResults = [];
      updateAddReviewSearchResults();
      state.addCuisine = ''; state.addPrice = 2; state.addPhotos = []; state.addVerifiedVisit = false; state.addWouldGoAgain = true;
      setTab('feed');
    }

    async function deleteReviewById(id) {
      const r = state.reviews.find(x => x.id === id);
      if (!r || r.by !== state.user?.displayName) return;
      if (!confirm('Delete this review? This cannot be undone.')) return;
      const k = getSavedKey(r);
      state.reviews = state.reviews.filter(x => x.id !== id);
      const i = state.saved.indexOf(k);
      if (i >= 0) state.saved.splice(i, 1);
      GROUP_LIST_NAMES.forEach(listName => {
        if (listName === 'Saved') return;
        const arr = state.groupLists[listName] || [];
        const j = arr.indexOf(k);
        if (j >= 0) arr.splice(j, 1);
      });
      delete state.comments[id];
      delete state.privateNotes[id];
      if (state.viewRestaurant && state.viewRestaurant.name === r.restaurant) state.panel = 'main';
      if (window.FOODIE_API?.enabled) {
        try {
          await window.FOODIE_API.deleteReview(id);
          await refreshFeed();
        } catch (e) {
          console.warn(e);
          state.reviews = state.reviews.concat([r]);
          render();
          alert('Could not delete: ' + (e.message || 'Please try again.'));
          return;
        }
      } else saveToStorage();
      render();
    }

    async function saveProfile() {
      const old = state.user.displayName;
      const newName = (document.getElementById('profileName')?.value || '').trim().slice(0, MAX_DISPLAY_NAME);
      const bio = (document.getElementById('profileBio')?.value || '').slice(0, 500);
      const p = state.profiles[newName || old] || state.profiles[old] || {};
      p.bio = bio;
      if (state.profiles[old]?.avatar) p.avatar = state.profiles[old].avatar;
      state.user.displayName = newName || old;
      state.profiles[state.user.displayName] = p;
      if (old !== state.user.displayName) delete state.profiles[old];
      if (window.FOODIE_API?.enabled) { try { await window.FOODIE_API.updateProfile(state.user.displayName, bio, p.avatar); } catch (e) { console.warn(e); } } else saveToStorage();
      state.panel = 'main';
      render();
    }

    async function handleProfilePhoto(input) {
      const f = input?.files?.[0];
      if (!f) return;
      if (!ALLOWED_IMAGE_TYPES.includes(f.type) || f.type === 'image/svg+xml') return;
      const uid = state.user?.displayName;
      if (!uid) return;
      if (!state.profiles[uid]) state.profiles[uid] = {};
      if (window.FOODIE_API?.enabled && window.FOODIE_API.uploadAvatar) {
        try {
          const url = await window.FOODIE_API.uploadAvatar(f);
          if (url) {
            state.profiles[uid].avatar = url;
            await window.FOODIE_API.updateProfile(uid, state.profiles[uid].bio || '', url);
            render();
          }
        } catch (e) {
          console.warn('Avatar upload failed, using local:', e);
          const r = new FileReader();
          r.onload = function() {
            processImageToSafeDataUrl(r.result, 100000, 500, function(safeUrl) {
              if (safeUrl) { state.profiles[uid].avatar = safeUrl; saveToStorage(); render(); }
            });
          };
          r.readAsDataURL(f);
        }
      } else {
        const r = new FileReader();
        r.onload = function() {
          processImageToSafeDataUrl(r.result, 100000, 500, function(safeUrl) {
            if (safeUrl) { state.profiles[uid].avatar = safeUrl; saveToStorage(); render(); }
          });
        };
        r.readAsDataURL(f);
      }
      input.value = '';
    }

    async function deleteProfilePhoto() {
      const uid = state.user?.displayName;
      if (!uid) return;
      if (!state.profiles[uid]) state.profiles[uid] = {};
      state.profiles[uid].avatar = '';
      if (window.FOODIE_API?.enabled) {
        try { await window.FOODIE_API.updateProfile(uid, state.profiles[uid].bio || '', null); } catch (e) { console.warn(e); }
      } else saveToStorage();
      render();
    }

    let nsfwModelPromise = null;
    function loadNsfwModel() {
      if (nsfwModelPromise) return nsfwModelPromise;
      nsfwModelPromise = new Promise(function(resolve) {
        if (typeof nsfwjs !== 'undefined') {
          nsfwjs.load().then(resolve).catch(function() { resolve(null); });
          return;
        }
        const tfScript = document.createElement('script');
        tfScript.src = 'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0';
        tfScript.onload = function() {
          const nsfw = document.createElement('script');
          nsfw.src = 'https://cdn.jsdelivr.net/npm/nsfwjs@2.4.2/dist/nsfwjs.min.js';
          nsfw.onload = function() {
            if (typeof tf !== 'undefined' && tf.enableProdMode) try { tf.enableProdMode(); } catch (e) {}
            nsfwjs.load().then(resolve).catch(function() { resolve(null); });
          };
          nsfw.onerror = function() { resolve(null); };
          document.head.appendChild(nsfw);
        };
        tfScript.onerror = function() { resolve(null); };
        document.head.appendChild(tfScript);
      });
      return nsfwModelPromise;
    }
    function isImageAppropriate(img, cb) {
      loadNsfwModel().then(function(model) {
        if (!model) { cb(true); return; }
        model.classify(img).then(function(predictions) {
          const byClass = {};
          predictions.forEach(function(p) { byClass[p.className] = p.probability; });
          const porn = byClass.Porn || 0, hentai = byClass.Hentai || 0, sexy = byClass.Sexy || 0;
          const ok = porn < NSFW_PORN_THRESHOLD && hentai < NSFW_HENTAI_THRESHOLD && sexy < NSFW_SEXY_THRESHOLD;
          cb(ok);
        }).catch(function() { cb(true); });
      }).catch(function() { cb(true); });
    }
    function processImageToSafeDataUrl(data, maxSize, maxDim, cb) {
      if (!data || typeof data !== 'string' || !data.startsWith('data:image/')) { cb(null); return; }
      const m = data.match(/^data:(image\/(jpeg|png|gif|webp));base64,/i);
      if (!m) { cb(null); return; }
      const img = new Image();
      img.onerror = function() { cb(null); };
      img.onload = function() {
        isImageAppropriate(img, function(ok) {
          if (!ok) { try { alert('This photo appears to contain inappropriate content and cannot be uploaded.'); } catch (e) {} cb(null); return; }
          let w = img.width, h = img.height;
          if (w > maxDim || h > maxDim) {
            const s = Math.min(1, maxDim / Math.max(w, h));
            w = Math.round(w * s); h = Math.round(h * s);
          }
          let scale = 1;
          if (w * h > 0) {
            const targetPx = maxSize / 0.5;
            if (w * h > targetPx) scale = Math.sqrt(targetPx / (w * h));
          }
          w = Math.max(1, Math.round(w * scale)); h = Math.max(1, Math.round(h * scale));
          const c = document.createElement('canvas');
          c.width = w; c.height = h;
          c.getContext('2d').drawImage(img, 0, 0, w, h);
          const out = c.toDataURL('image/jpeg', 0.8);
          cb(out.length <= maxSize * 1.2 ? out : c.toDataURL('image/jpeg', 0.6));
        });
      };
      img.src = data;
    }
    function togglePhotoAddSheet() {
      const menu = document.getElementById('photoAddMenu');
      const backdrop = document.getElementById('photoAddBackdrop');
      if (!menu || !backdrop) return;
      const open = menu.classList.contains('show');
      menu.classList.toggle('show', !open);
      backdrop.classList.toggle('show', !open);
    }
    function closePhotoAddSheet() {
      const menu = document.getElementById('photoAddMenu');
      const backdrop = document.getElementById('photoAddBackdrop');
      if (menu) menu.classList.remove('show', 'show-mobile');
      if (backdrop) backdrop.classList.remove('show');
    }
    let cameraStream = null;
    async function openCameraCapture(ev) {
      if (!window.isSecureContext) {
        closePhotoAddSheet();
        const modal = document.getElementById('cameraModal');
        const errEl = document.getElementById('cameraError');
        if (modal && errEl) {
          errEl.innerHTML = 'Camera requires HTTPS or localhost. Open this app at <strong>http://localhost:8080</strong> (run: npm run dev:pwa in foodie-website folder).';
          errEl.style.display = 'block';
          document.getElementById('cameraCaptureBtn').disabled = false;
          modal.classList.add('show');
        }
        return;
      }
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        closePhotoAddSheet();
        const modal = document.getElementById('cameraModal');
        const errEl = document.getElementById('cameraError');
        if (modal && errEl) {
          errEl.textContent = 'Camera not supported. Use "Choose from Library" instead.';
          errEl.style.display = 'block';
          document.getElementById('cameraCaptureBtn').disabled = false;
          modal.classList.add('show');
        }
        return;
      }
      var gumPromise = navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: false });
      closePhotoAddSheet();
      const modal = document.getElementById('cameraModal');
      const video = document.getElementById('cameraVideo');
      const errEl = document.getElementById('cameraError');
      const captureBtn = document.getElementById('cameraCaptureBtn');
      if (!modal || !video || !errEl) return;
      errEl.style.display = 'none';
      errEl.textContent = '';
      captureBtn.disabled = true;
      modal.classList.add('show');
      try {
        cameraStream = await gumPromise;
        video.srcObject = cameraStream;
        captureBtn.disabled = false;
      } catch (e) {
        var msg = 'Camera access denied or unavailable. ';
        if (/Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent)) {
          msg += 'In Safari: Settings > Websites > Camera — set this site to "Ask" or "Allow", then try again.';
        } else {
          msg += 'Please allow camera permission when prompted and try again.';
        }
        errEl.innerHTML = msg + ' <button type="button" class="camera-btn camera-close-btn" style="margin-top:12px" onclick="openCameraCapture(event)">Retry</button>';
        errEl.style.display = 'block';
        captureBtn.disabled = false;
      }
    }
    function closeCameraCapture() {
      const modal = document.getElementById('cameraModal');
      const video = document.getElementById('cameraVideo');
      if (cameraStream) {
        cameraStream.getTracks().forEach(t => t.stop());
        cameraStream = null;
      }
      if (video) video.srcObject = null;
      if (modal) modal.classList.remove('show');
    }
    function captureFromCamera() {
      const video = document.getElementById('cameraVideo');
      if (!video || !video.srcObject || video.readyState < 2) return;
      const c = document.createElement('canvas');
      c.width = video.videoWidth;
      c.height = video.videoHeight;
      c.getContext('2d').drawImage(video, 0, 0);
      const dataUrl = c.toDataURL('image/jpeg', 0.9);
      closeCameraCapture();
      processImageToSafeDataUrl(dataUrl, PHOTO_MAX_SIZE, PHOTO_MAX_DIM, function(safeUrl) {
        if (safeUrl && state.addPhotos.length < 4) {
          state.addPhotos = state.addPhotos || [];
          state.addPhotos.push(safeUrl);
          saveToStorage();
          render();
        }
      });
    }
    function handlePhotoUpload(input) {
      const files = input.files;
      if (!files || !files.length) return;
      for (let i = 0; i < Math.min(files.length, 4); i++) {
        const f = files[i];
        if (!ALLOWED_IMAGE_TYPES.includes(f.type) || f.type === 'image/svg+xml') continue;
        if (f.size > PHOTO_MAX_SIZE * 3) continue;
        const r = new FileReader();
        r.onload = function() {
            const data = r.result;
            processImageToSafeDataUrl(data, PHOTO_MAX_SIZE, PHOTO_MAX_DIM, function(safeUrl) {
              if (safeUrl && state.addPhotos.length < 4) {
                state.addPhotos = state.addPhotos || [];
                state.addPhotos.push(safeUrl);
                saveToStorage(); render();
              }
            });
        };
        r.readAsDataURL(f);
      }
      input.value = '';
    }

    async function addReview() {
      if (state._addReviewInProgress) return;
      const text = ((document.querySelector('.add-review-textarea') || {}).value || state.reviewText || '').trim();
      if (!text || state.rating < 1) { alert('Please add a rating and write your review.'); return; }
      if (text.length > MAX_REVIEW_TEXT) { alert('Review is too long. Please keep it under ' + MAX_REVIEW_TEXT + ' characters.'); return; }
      if (state.editingReview) {
        const idx = state.reviews.findIndex(r => r.id === state.editingReview.id);
        if (idx >= 0) {
          const searchName = (state.restaurantSearch || state.editingReview.restaurant || '').trim();
          let place = state.selectedPlace || { name: state.editingReview.restaurant, lat: state.editingReview.lat, lng: state.editingReview.lng };
          if (searchName) {
            const loc = state.userLocation || { lat: state.editingReview.lat, lng: state.editingReview.lng };
            const geocoded = await geocodePlace(searchName, loc.lat, loc.lng);
            if (geocoded) place = { name: (state.restaurantSearch || state.editingReview.restaurant || '').trim().slice(0, MAX_RESTAURANT_NAME), lat: geocoded.lat, lng: geocoded.lng };
            else if (!state.selectedPlace && state.restaurantSearch?.trim() !== state.editingReview.restaurant) place = { name: searchName.slice(0, MAX_RESTAURANT_NAME), lat: state.editingReview.lat, lng: state.editingReview.lng };
          }
          const updated = { ...state.reviews[idx], text: text.trim(), rating: state.rating, restaurant: place.name, lat: place.lat, lng: place.lng, cuisine: state.addCuisine || 'Various', price: state.addPrice || 2, photos: (state.addPhotos || []).filter(isSafePhotoUrl), verifiedVisit: state.addVerifiedVisit, wouldGoAgain: state.addWouldGoAgain };
          state.reviews[idx] = updated;
          if (window.FOODIE_API?.enabled) { try { await window.FOODIE_API.saveReview(updated); } catch (e) { alert('Could not save: ' + (e.message || 'Please try again.')); render(); return; } } else saveToStorage();
        }
        cancelEdit();
        return;
      }
      const inputName = (document.getElementById('addReviewRestaurantInput')?.value || state.restaurantSearch || '').trim();
      let place = state.selectedPlace;
      if (!place && inputName) {
        const loc = state.userLocation || { lat: 37.37, lng: -122.03 };
        place = { name: inputName, lat: loc.lat, lng: loc.lng };
        const geocoded = await geocodePlace(inputName, loc.lat, loc.lng);
        if (geocoded) place = { name: inputName, lat: geocoded.lat, lng: geocoded.lng };
      }
      if (!place && !inputName) { alert('Please enter a restaurant name.'); return; }
      state._addReviewInProgress = true;
      try {
        const restName = (place.name || state.restaurantSearch.trim() || '').slice(0, MAX_RESTAURANT_NAME);
        const reviewId = (typeof crypto !== 'undefined' && crypto.randomUUID) ? crypto.randomUUID() : (Date.now() + '-' + Math.random().toString(36).slice(2, 11));
        state.reviews.unshift({
          id: reviewId,
          restaurant: restName,
          lat: parseFloat(place.lat),
          lng: parseFloat(place.lng),
          by: state.user.displayName,
          text: text.trim(),
          rating: state.rating,
          date: Date.now(),
          level: 3,
          likes: 0,
          liked: false,
          cuisine: state.addCuisine || 'Various',
          price: state.addPrice || 2,
          photos: (state.addPhotos || []).filter(isSafePhotoUrl),
          verifiedVisit: state.addVerifiedVisit,
          wouldGoAgain: state.addWouldGoAgain
        });
        state.rating = 0;
        state.reviewText = '';
        state.restaurantSearch = '';
        state.selectedPlace = null;
        state.searchResults = [];
        state.editingReview = null;
        state.addCuisine = ''; state.addPrice = 2; state.addPhotos = []; state.addVerifiedVisit = false; state.addWouldGoAgain = true;
        const newReview = state.reviews[0];
        if (window.FOODIE_API?.enabled) {
          await window.FOODIE_API.saveReview(newReview);
          await refreshFeed();
        } else saveToStorage();
        setTab('feed');
      } catch (e) {
        if (state.reviews.length > 0) state.reviews.shift();
        alert('Could not save review: ' + (e.message || 'Please check your connection and try again.'));
        render();
      } finally {
        state._addReviewInProgress = false;
      }
    }

    function isValidCoord(v) { const n = parseFloat(v); return typeof n === 'number' && !isNaN(n) && n >= -90 && n <= 90; }
    function isValidLng(v) { const n = parseFloat(v); return typeof n === 'number' && !isNaN(n) && n >= -180 && n <= 180; }
    function getMapRestaurants() {
      let list = state.reviews.filter(r => isValidCoord(r.lat) && isValidLng(r.lng));
      if (state.mapFilter === '1') list = list.filter(r => getEffectiveLevel(r) === 1);
      else if (state.mapFilter === '2') list = list.filter(r => getEffectiveLevel(r) === 2);
      if (state.mapCuisine) list = list.filter(r => (r.cuisine||'Various') === state.mapCuisine);
      if (state.mapPrice) list = list.filter(r => (r.price||2) <= parseInt(state.mapPrice));
      const minR = parseInt(state.mapMinRating) || 0;
      if (minR > 0) list = list.filter(r => (r.rating||0) >= minR);
      const byLocation = {};
      list.forEach(r => {
        const lat = parseFloat(r.lat), lng = parseFloat(r.lng);
        const k = lat.toFixed(5) + ',' + lng.toFixed(5);
        const lvl = getEffectiveLevel(r);
        if (!byLocation[k]) {
          byLocation[k] = { name: r.restaurant, lat: lat, lng: lng, level: lvl, reviews: [], cuisines: new Set(), prices: [] };
        }
        const loc = byLocation[k];
        if (lvl === 0) {
          if (loc.level === undefined || loc.level === 0) loc.level = 0;
        } else {
          if (loc.level === undefined || loc.level === 0 || lvl < loc.level) loc.level = lvl;
        }
        loc.reviews.push(r);
        if (r.cuisine) loc.cuisines.add(r.cuisine);
        if (r.price) loc.prices.push(r.price);
      });
      return Object.values(byLocation).map(loc => ({
        ...loc,
        cuisines: [...loc.cuisines].filter(Boolean),
        avgRating: loc.reviews.length ? (loc.reviews.reduce((s,r)=>s+(r.rating||0),0) / loc.reviews.length).toFixed(1) : '-',
        price: loc.prices.length ? Math.max(...loc.prices) : 2
      }));
    }

    function getRestaurantNetworkScore(lat, lng) {
      const atLoc = state.reviews.filter(r =>
        Math.abs(r.lat - lat) < 0.01 && Math.abs(r.lng - lng) < 0.01 &&
        (getEffectiveLevel(r) === 1 || getEffectiveLevel(r) === 2 || getEffectiveLevel(r) === 3)
      );
      if (!atLoc.length) return null;
      const uniqueBy = [...new Set(atLoc.map(r => r.by))];
      const avg = atLoc.reduce((s, r) => s + (r.rating || 0), 0) / atLoc.length;
      return { avgRating: avg.toFixed(1), count: uniqueBy.length };
    }

    function getMapBubbleSize(avgRating, reviewCount) {
      const avg = parseFloat(avgRating) || 3;
      const count = Math.min(reviewCount || 1, 5);
      const quality = Math.max(0, (avg - 2) / 3);
      const volume = 0.5 + 0.5 * (count / 5);
      const size = Math.round(18 + 14 * quality * volume);
      return Math.max(16, Math.min(36, size));
    }

    function getFilteredReviews() {
      let list = state.reviews;
      if (state.panel === 'myreviews') list = list.filter(r => r.userId === state.user?.id || (r.by || '').trim().toLowerCase() === (state.user?.displayName || '').trim().toLowerCase());
      const q = (state.feedSearch || '').toLowerCase().trim();
      if (q) list = list.filter(r =>
        (r.restaurant||'').toLowerCase().includes(q) ||
        (r.by||'').toLowerCase().includes(q) ||
        (r.text||'').toLowerCase().includes(q) ||
        ((r.cuisine||'')+'').toLowerCase().includes(q)
      );
      if (state.feedCuisine) list = list.filter(r => (r.cuisine||'Various') === state.feedCuisine);
      if (state.feedPrice) list = list.filter(r => (r.price||2) <= parseInt(state.feedPrice));
      if (state.feedMinRating) list = list.filter(r => (r.rating||0) >= parseInt(state.feedMinRating));
      const seenIds = new Set();
      list = list.filter(function(r, i) {
        if (r.id && seenIds.has(r.id)) return false;
        const dup = list.find(function(x, j) {
          if (j >= i) return false;
          if (r.id && x.id && r.id === x.id) return true;
          const sameUser = (r.userId && x.userId && r.userId === x.userId) || (x.by || '').trim().toLowerCase() === (r.by || '').trim().toLowerCase();
          const sameLoc = Math.abs(parseFloat(x.lat) - parseFloat(r.lat)) < 0.001 && Math.abs(parseFloat(x.lng) - parseFloat(r.lng)) < 0.001;
          const nearTime = Math.abs((x.date||0) - (r.date||0)) < 86400000;
          return sameUser && sameLoc && nearTime;
        });
        if (r.id) seenIds.add(r.id);
        return !dup;
      });
      state._feedLevelCounts = { l1: list.filter(r=>getEffectiveLevel(r)===1).length, l2: list.filter(r=>getEffectiveLevel(r)===2).length, l3: list.filter(r=>getEffectiveLevel(r)===3).length };
      if (state.feedLevelFilter === '1') list = list.filter(r => getEffectiveLevel(r) === 1);
      else if (state.feedLevelFilter === '2') list = list.filter(r => getEffectiveLevel(r) === 2);
      else if (state.feedLevelFilter === '3') list = list.filter(r => getEffectiveLevel(r) === 3);
      return list;
    }

    function getReviewAlsoReviewedHtml(r, mutualCount, networkScore) {
      const alsoBy = getAlsoReviewedBy(r);
      if (alsoBy.length > 0) {
        return '<div style="padding:2px 0;font-size:0.8rem;color:#666;cursor:pointer;text-decoration:underline;text-underline-offset:2px" onclick="showReviewersModal(\'' + r.id + '\')" title="' + escapeHtml(alsoBy.join(', ')) + '">Also reviewed by ' + escapeHtml(alsoBy.slice(0,3).join(', ')) + (alsoBy.length > 3 ? ' and ' + (alsoBy.length - 3) + ' more' : '') + '</div>';
      }
      if (mutualCount > 0) {
        const myName = state.user ? state.user.displayName : null;
        const connNames = myName ? (state.connections[myName] || []) : [];
        const names = state.reviews.filter(function(x) {
          return Math.abs(x.lat - r.lat) < 0.01 && Math.abs(x.lng - r.lng) < 0.01 && x.by !== r.by && connNames.includes(x.by);
        }).map(function(x) { return x.by; }).join(', ');
        return '<div class="mutual-connections" style="cursor:pointer;text-decoration:underline;text-underline-offset:2px" onclick="showReviewersModal(\'' + r.id + '\')" title="' + escapeHtml(names) + '">' + mutualCount + ' ' + (mutualCount === 1 ? 'friend' : 'friends') + ' also reviewed this</div>';
      }
      if (networkScore && networkScore.count > 0) {
        var nsStyle = 'font-size:0.8rem;color:#333;margin-top:4px;font-weight:500;';
        var nsAttrs = '';
        if (networkScore.count > 1) {
          nsStyle += 'cursor:pointer;text-decoration:underline;text-underline-offset:2px';
          nsAttrs = ' onclick="showReviewersModal(\'' + r.id + '\')" title="View reviewers"';
        }
        return '<div class="network-score" style="' + nsStyle + '"' + nsAttrs + '>Network: ' + networkScore.avgRating + ' ★ (' + networkScore.count + ' ' + (networkScore.count === 1 ? 'review' : 'reviews') + ')</div>';
      }
      return '';
    }

    function renderReviewCard(r) {
      const effLevel = getEffectiveLevel(r);
      const isOwn = (effLevel === 3) || (state.user && (r.userId === state.user.id || (r.by || '').trim().toLowerCase() === (state.user.displayName || '').trim().toLowerCase()));
      const comments = getComments(r.id);
      const saved = isSaved(r);
      const mutualCount = getMutualConnectionsCount(r);
      const trustScore = !isOwn && (effLevel === 1 || effLevel === 2) ? getTrustScore(r.by) : null;
      const networkScore = getRestaurantNetworkScore(r.lat, r.lng);
      const privateNote = isOwn ? getPrivateNote(r.id) : '';
      return `
        <div class="review-card" data-review-id="${r.id}">
          <div class="review-card-header">
            <div class="review-avatar ${effLevel===3?'self':''}">${escapeHtml(getInitials(r.by))}</div>
            <div class="review-header-meta">
              <div class="review-header-top">
                <span class="review-by">${escapeHtml(r.by)}</span>
                ${canConnectWith(r.by) && !r.seed ? (hasPendingRequestTo(r.by) ? `<button class="connect-btn pending" title="Request sent">+</button>` : `<button class="connect-btn" onclick="sendConnectionRequest('${(r.by||'').replace(/'/g,"\\'")}'); render()" title="Connect">+</button>`) : ''}
                <span class="review-connection${r.seed?' badge-discover':''}">${getConnectionLabel(effLevel, r)}</span>
                ${r.verifiedVisit ? `<span class="badge-verified" title="Verified visit">✓ Verified</span>` : ''}
                ${r.wouldGoAgain ? `<span class="badge-again" title="Would go again">🔄 Again</span>` : ''}
                ${trustScore !== null ? `<span class="badge-trust" title="Taste match">${trustScore}% match</span>` : ''}
                ${isOwn ? `<button class="review-edit-btn" onclick="editReviewById('${r.id}')" title="Edit">✏️ Edit</button><button class="review-edit-btn" onclick="deleteReviewById('${r.id}')" title="Delete" style="color:#c62828">🗑️ Delete</button>` : ''}
              </div>
              <div class="review-date">${formatDate(r.date)}</div>
              <div class="review-restaurant" onclick="viewRestaurantFromReviewId('${r.id}')" style="cursor:pointer;touch-action:manipulation;-webkit-tap-highlight-color:rgba(0,0,0,0.1)" role="button" tabindex="0" aria-label="View ${escapeHtml(r.restaurant)} on map" title="${(()=>{const a=getAlsoReviewedBy(r); return a.length ? 'Also reviewed by '+a.join(', ')+' • Tap to view on map' : 'Tap to view on map'})()}">${escapeHtml((r.restaurant||'').substring(0,60))}${(r.restaurant||'').length>60?'...':''}</div>
              ${getReviewAlsoReviewedHtml(r, mutualCount, networkScore)}
              ${(r.cuisine||r.price) ? `<div style="font-size:0.75rem;color:#666;margin-top:2px">${escapeHtml(r.cuisine||'')} ${PRICE_LABELS[(r.price||2)-1]||''}</div>` : ''}
            </div>
          </div>
          <div class="review-card-body">
            <p class="review-text">${escapeHtml(r.text)}</p>
            ${(getReviewPhotoUrls(r).length) ? `<div class="review-photos">${getReviewPhotoUrls(r).map(p=>`<img src="${p}" alt="Review photo" onerror="this.style.display='none'">`).join('')}</div>` : ''}
            <div class="review-rating">${'❤️'.repeat(r.rating)}</div>
          </div>
          <div class="review-actions">
            <button class="review-action-btn ${r.liked?'liked':''}" onclick="toggleLike('${r.id}')" aria-label="Like" title="${((r.likedBy||[]).length) ? 'Liked by ' + (r.likedBy||[]).slice(0,3).join(', ') + ((r.likedBy||[]).length>3 ? ' and ' + ((r.likedBy||[]).length-3) + ' more' : '') : 'Like'}">${r.liked?'❤️':'🤍'} Like</button>
            <button class="review-action-btn" onclick="document.getElementById('commentInput${r.id}')?.focus()" aria-label="Comment">💬 Comment ${comments.length?`(${comments.length})`:''}</button>
            <button class="review-action-btn" onclick="shareReview('${r.id}')" aria-label="Share">↗️ Share</button>
            <button class="review-action-btn" onclick="viewRestaurantFromReviewId('${r.id}')" aria-label="View on map">📍 Map</button>
            <button class="review-action-btn" onclick="fixLocationForRestaurant('${(r.restaurant||'').replace(/'/g,"\\'")}', ${(parseFloat(r.lat)||0)}, ${(parseFloat(r.lng)||0)}, '${(r.id||'').replace(/'/g,"\\'")}')" style="font-size:0.85rem" title="Fix wrong location">🔧 Fix location</button>
            <button class="review-action-btn" onclick="toggleSaveById('${r.id}')" aria-label="Save">${saved?'🔖':'📑'} ${saved?'Saved':'Save'}</button>
            ${isOwn ? `<button class="review-action-btn" onclick="editReviewById('${r.id}')">✏️ Edit</button><button class="review-action-btn" onclick="deleteReviewById('${r.id}')" style="color:#c62828" aria-label="Delete">🗑️ Delete</button>` : ''}
          </div>
          <div class="review-actions-secondary">
            <div class="review-list-dropdown">
              <button type="button" class="review-action-btn list-trigger-btn" onclick="toggleListDropdown(event, this)" aria-label="Add to list">📋 Add to list</button>
              <div class="list-dropdown-backdrop" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.4);z-index:199" onclick="var w=this.closest('.review-list-dropdown'); if(w){var m=w.querySelector('.list-dropdown-menu'); var b=w.querySelector('.list-dropdown-backdrop'); if(m){m.style.display='none';m.classList.remove('show-mobile');} if(b)b.style.display='none'}"></div>
              <div class="list-dropdown-menu" style="display:none;position:absolute;top:100%;left:0;margin-top:4px;background:white;border-radius:8px;box-shadow:0 4px 12px rgba(0,0,0,0.15);padding:8px;min-width:160px;z-index:200;max-height:50vh;overflow-y:auto">
                ${GROUP_LIST_NAMES.filter(n=>n!=='Saved').map(listName=>{
                  const inList = (state.groupLists[listName]||[]).includes(getSavedKey(r));
                  return `<button onclick="toggleList('${r.id}','${listName}'); var w=this.closest('.review-list-dropdown'); if(w){var m=w.querySelector('.list-dropdown-menu'); var b=w.querySelector('.list-dropdown-backdrop'); if(m){m.style.display='none';m.classList.remove('show-mobile');} if(b)b.style.display='none'}" style="display:block;width:100%;padding:12px 16px;text-align:left;border:none;background:none;cursor:pointer;font-size:1rem">${inList?'✓ ':''}${listName}</button>`;
                }).join('')}
              </div>
            </div>
          </div>
          ${isOwn && (privateNote || true) ? `<div class="private-note" style="padding:8px 16px 8px 76px;background:#f9f9f9;border-top:1px solid #eee">
            <label style="font-size:0.8rem;color:#666">Private note (only you see):</label>
            <input type="text" value="${(privateNote||'').replace(/"/g,'&quot;')}" placeholder="e.g. Try the lamb biryani" onchange="setPrivateNote('${r.id}',this.value)" style="width:100%;padding:8px;margin-top:4px;border:1px solid #ddd;border-radius:6px;font-size:0.9rem">
          </div>` : ''}
          ${comments.length ? `<div class="review-comments">${comments.map(c=>`<div class="comment-item" style="display:flex;align-items:center;gap:6px;flex-wrap:wrap"><strong>${escapeHtml(c.by)}:</strong>${canConnectWith(c.by) && !r.seed ? (hasPendingRequestTo(c.by) ? `<button class="connect-btn pending" title="Request sent">+</button>` : `<button class="connect-btn" onclick="sendConnectionRequest('${(c.by||'').replace(/'/g,"\\'")}'); render()" title="Connect">+</button>`) : ''}<span>${escapeHtml(c.text)}</span></div>`).join('')}</div>` : ''}
          ${!r.seed ? `<div class="review-comments">
            <div class="comment-form">
              <input type="text" id="commentInput${r.id}" placeholder="Write a comment..." onkeydown="if(event.key==='Enter')addComment('${r.id}',this.value)&&(this.value='')">
              <button onclick="var i=document.getElementById('commentInput${r.id}'); addComment('${r.id}',i.value); i.value=''">Post</button>
            </div>
          </div>` : ''}
          ${(r.likes||0) > 0 ? `<div style="padding: 0 16px 4px 76px; font-size: 0.8rem; color: #666; cursor: pointer; text-decoration: underline; text-underline-offset: 2px" onclick="showLikersModal('${r.id}')" title="${(r.likedBy||[]).join(', ')}">${r.likes} ${r.likes===1?'like':'likes'}</div>` : ''}
        </div>
      `;
    }

    function openMenu() { state.menuOpen = true; render(); }
    function closeMenu() { state.menuOpen = false; render(); }
    function closeLikersModal() { state.viewLikersReviewId = null; render(); }
    function showReviewersModal(reviewId) {
      const r = state.reviews.find(x => x.id === reviewId);
      if (!r) return;
      const reviewers = getAlsoReviewedBy(r);
      const atLoc = getReviewsAtLocation(r);
      if (!reviewers.length && atLoc.length < 2) return;
      state.viewReviewersReviewId = reviewId;
      render();
    }
    function closeReviewersModal() { state.viewReviewersReviewId = null; render(); }

    function updateFeedCards() {
      const list = getFilteredReviews();
      const statsEl = document.getElementById('feedStats');
      if (statsEl) {
        const c = state._feedLevelCounts || {};
        const l1 = c.l1 || 0, l2 = c.l2 || 0, l3 = c.l3 || 0;
        const total = list.length;
        const lev = state.feedLevelFilter;
        const tgl = function(n) { return "event.preventDefault();state.feedLevelFilter=state.feedLevelFilter==='"+n+"'?'':'"+n+"';updateFeedCards();render();return false"; };
        const html = total + ' reviews' + (total ? ' · <a href="#" onclick="' + tgl('1') + '" style="color:' + (lev === '1' ? '#e31919' : '#006CE0') + ';text-decoration:underline;cursor:pointer">1st: ' + l1 + '</a> · <a href="#" onclick="' + tgl('2') + '" style="color:' + (lev === '2' ? '#e31919' : '#FF8D00') + ';text-decoration:underline;cursor:pointer">2nd: ' + l2 + '</a>' + (l3 ? ' · <a href="#" onclick="' + tgl('3') + '" style="color:' + (lev === '3' ? '#e31919' : '#333') + ';text-decoration:underline;cursor:pointer">Yours: ' + l3 + '</a>' : '') : '');
        statsEl.innerHTML = html;
      }
      const el = document.getElementById('feedCards');
      if (!el) return;
      el.innerHTML = list.map(r => renderReviewCard(r)).join('');
    }

    let mapSearchDebounce = null;
    function updateMapSearch() {
      const el = document.getElementById('mapSearchInput');
      if (el) state.mapSearch = el.value;
      clearTimeout(mapSearchDebounce);
      mapSearchDebounce = setTimeout(function() { if (state.tab === 'map') initMap(); }, 400);
    }

    async function geocodeMapSearch() {
      const el = document.getElementById('mapSearchInput');
      const q = (el?.value || state.mapSearch || '').trim();
      if (!q) return;
      const coords = await geocodePlace(q);
      if (coords && map) {
        map.setView([coords.lat, coords.lng], 14);
      }
    }

    function myLocationMap() {
      if (!navigator.geolocation || !map) return;
      const showError = (msg) => { try { alert(msg || 'Could not get your location. Check that location is enabled.'); } catch (e) {} };
      const timeout = setTimeout(() => showError('Location request timed out.'), 15000);
      navigator.geolocation.getCurrentPosition(
        pos => {
          clearTimeout(timeout);
          const { latitude, longitude } = pos.coords;
          state.userLocation = { lat: latitude, lng: longitude };
          if (userLocationMarker && map.hasLayer(userLocationMarker)) map.removeLayer(userLocationMarker);
          const icon = L.divIcon({
            className: 'user-location-marker',
            html: '<div style="width:20px;height:20px;background:#2196F3;border:3px solid white;border-radius:50%;box-shadow:0 2px 6px rgba(0,0,0,0.4)"></div>',
            iconSize: [20, 20],
            iconAnchor: [10, 10]
          });
          userLocationMarker = L.marker([latitude, longitude], { icon }).addTo(map);
          userLocationMarker.bindPopup('You are here');
          map.flyTo([latitude, longitude], 15, { duration: 0.8 });
        },
        err => {
          clearTimeout(timeout);
          if (err.code === 1) showError('Location access denied. Enable location in your browser or device settings.');
          else if (err.code === 2) showError('Location unavailable.');
          else showError();
        },
        { enableHighAccuracy: true, timeout: 12000, maximumAge: 0 }
      );
    }

    function render() {
      const app = document.getElementById('app');
      if (!state._bootstrapComplete) {
        app.innerHTML = '<div style="min-height:200px;display:flex;align-items:center;justify-content:center;font-size:1.1rem;color:#666">Loading Foodie…</div>';
        return;
      }
      if (!state.user) {
        const useSupabase = window.FOODIE_API && window.FOODIE_API.enabled;
        if (useSupabase) {
          if (state.authMode === 'forgot') {
            app.innerHTML = `
          <div class="signup-page">
            <div class="signup-top">
              <img src="logo/Foodie_white.svg" alt="Foodie" class="signup-logo-img">
            </div>
            <div class="signup-bottom">
              <div class="signup-actions">
                <p class="signup-demo-label">Reset password</p>
                <p style="font-size:0.9rem;color:rgba(255,255,255,0.8);margin-bottom:16px">Enter your email and we'll send you a link to reset your password.</p>
                <input type="email" id="authForgotEmail" placeholder="Email" style="width:100%;max-width:320px;padding:14px;border:2px solid rgba(255,255,255,0.6);border-radius:8px;background:rgba(255,255,255,0.1);color:white;font-size:1rem" />
                <div id="authError" style="color:#ff6b6b;font-size:0.9rem;min-height:20px"></div>
                <button class="signup-btn" onclick="handleForgotPassword()" style="font-size:1.1rem">Send reset link</button>
                <button class="signup-btn" onclick="state.authMode='signup'; render()" style="font-size:0.95rem;background:rgba(255,255,255,0.1)">← Back</button>
              </div>
            </div>
          </div>
        `;
          } else if (state.authMode === 'reset') {
            app.innerHTML = `
          <div class="signup-page">
            <div class="signup-top">
              <img src="logo/Foodie_white.svg" alt="Foodie" class="signup-logo-img">
            </div>
            <div class="signup-bottom">
              <div class="signup-actions">
                <p class="signup-demo-label">Set new password</p>
                <input type="password" id="authNewPassword" placeholder="New password (min 6 chars)" style="width:100%;max-width:320px;padding:14px;border:2px solid rgba(255,255,255,0.6);border-radius:8px;background:rgba(255,255,255,0.1);color:white;font-size:1rem" />
                <input type="password" id="authConfirmPassword" placeholder="Confirm password" style="width:100%;max-width:320px;padding:14px;border:2px solid rgba(255,255,255,0.6);border-radius:8px;background:rgba(255,255,255,0.1);color:white;font-size:1rem" />
                <div id="authError" style="color:#ff6b6b;font-size:0.9rem;min-height:20px"></div>
                <button class="signup-btn" onclick="handleSetNewPassword()" style="font-size:1.1rem">Set password</button>
                <a href="#" onclick="state.authMode='signup'; if(window.FOODIE_API?.enabled)window.FOODIE_API.signOut(); if(history.replaceState)history.replaceState({},'',location.pathname); render(); return false" style="font-size:0.9rem;color:rgba(255,255,255,0.9);margin-top:12px;display:inline-block;text-decoration:underline">← Back to sign in</a>
              </div>
            </div>
          </div>
        `;
          } else {
          app.innerHTML = `
          <div class="signup-page">
            <div class="signup-top">
              <img src="logo/Foodie_white.svg" alt="Foodie" class="signup-logo-img">
            </div>
            <div class="signup-bottom">
              <div class="signup-actions">
                <p class="signup-demo-label">Sign up or log in to see friends' reviews</p>
                <input type="text" id="authDisplayName" placeholder="Display name" style="width:100%;max-width:320px;padding:14px;border:2px solid rgba(255,255,255,0.6);border-radius:8px;background:rgba(255,255,255,0.1);color:white;font-size:1rem" />
                <input type="email" id="authEmail" placeholder="Email" style="width:100%;max-width:320px;padding:14px;border:2px solid rgba(255,255,255,0.6);border-radius:8px;background:rgba(255,255,255,0.1);color:white;font-size:1rem" />
                <input type="password" id="authPassword" placeholder="Password (min 6 chars)" style="width:100%;max-width:320px;padding:14px;border:2px solid rgba(255,255,255,0.6);border-radius:8px;background:rgba(255,255,255,0.1);color:white;font-size:1rem" />
                <div id="authError" style="color:#ff6b6b;font-size:0.9rem;min-height:20px"></div>
                <button class="signup-btn" onclick="handleSupabaseSignUp()" style="font-size:1.1rem">Sign up</button>
                <button class="signup-btn" onclick="handleSupabaseSignIn()" style="font-size:1.1rem;background:rgba(255,255,255,0.15)">Log in</button>
                <a href="#" onclick="state.authMode='forgot'; render(); return false" style="font-size:0.9rem;color:rgba(255,255,255,0.9);margin-top:12px;display:inline-block;text-decoration:underline">Forgot password?</a>
                <p style="font-size:0.8rem;color:rgba(255,255,255,0.7);margin-top:16px;max-width:320px">📱 Add to home screen: iPhone → Share → Add to Home Screen. Android → Open in Chrome, then menu ⋮ → Install app</p>
              </div>
            </div>
          </div>
        `;
          }
        } else {
          app.innerHTML = `
          <div class="signup-page">
            <div class="signup-top">
              <img src="logo/Foodie_white.svg" alt="Foodie" class="signup-logo-img">
            </div>
            <div class="signup-bottom">
              <div class="signup-actions">
                <p class="signup-demo-label">Demo: try with phone or quick login</p>
                <div style="display:flex;gap:8px;width:100%;max-width:320px">
                  <select id="signupCountry" style="flex:0 0 80px;padding:14px;border:2px solid rgba(255,255,255,0.6);border-radius:8px;background:rgba(255,255,255,0.1);color:white;font-size:1rem">
                    <option value="+1">🇺🇸 +1</option>
                    <option value="+44">🇬🇧 +44</option>
                    <option value="+91">🇮🇳 +91</option>
                    <option value="+81">🇯🇵 +81</option>
                    <option value="+33">🇫🇷 +33</option>
                    <option value="+49">🇩🇪 +49</option>
                    <option value="+61">🇦🇺 +61</option>
                  </select>
                  <input type="tel" id="signupPhone" placeholder="Phone number" style="flex:1;padding:14px;border:2px solid rgba(255,255,255,0.6);border-radius:8px;background:rgba(255,255,255,0.1);color:white;font-size:1rem" />
                </div>
                <input type="email" id="signupEmail" placeholder="Or use email" style="width:100%;max-width:320px;padding:14px;border:2px solid rgba(255,255,255,0.6);border-radius:8px;background:rgba(255,255,255,0.1);color:white;font-size:1rem" />
                <button class="signup-btn" onclick="login('Demo User')" style="font-size:1.2rem">SIGNUP / LOGIN (Demo)</button>
                <p style="font-size:0.8rem;color:rgba(255,255,255,0.6);margin-top:8px">In demo, any input works. Real app would verify via OTP.</p>
              </div>
            </div>
          </div>
        `;
        }
        return;
      }

      const reviews = getFilteredReviews();
      const mapRestaurants = getMapRestaurants();

      let mainContent = '';
      if (state.panel === 'editprofile') {
        const uid = state.user?.displayName || '';
        const prof = state.profiles[uid] || {};
        const myReviews = state.reviews.filter(r => r.userId === state.user?.id || (r.by || '').trim().toLowerCase() === (uid || '').trim().toLowerCase()).length;
        mainContent = `<div class="main"><div style="padding:16px;background:white;border-radius:8px;max-width:400px;margin:0 auto">
          <h2 style="margin-bottom:16px">Edit Profile</h2>
          <div style="text-align:center;margin-bottom:16px">
            <label style="cursor:pointer;display:inline-block">
              <div class="menu-sidebar-avatar" style="margin:0 auto;background-image:url(${getSafeAvatarUrl(prof)||''});background-size:cover;background-position:center">${getSafeAvatarUrl(prof) ? '' : getInitials(uid)}</div>
              <input type="file" accept="image/*" onchange="handleProfilePhoto(this)" style="display:none">
              <div style="font-size:0.8rem;color:#666;margin-top:4px">Tap to change photo</div>
            </label>
            ${getSafeAvatarUrl(prof) ? `<button type="button" onclick="deleteProfilePhoto()" style="display:block;margin:8px auto 0;padding:6px 12px;background:#666;color:white;border:none;border-radius:6px;cursor:pointer;font-size:0.85rem">Remove photo</button>` : ''}
          </div>
          <input type="text" placeholder="Name" value="${(uid||'').replace(/"/g,'&quot;')}" id="profileName" maxlength="${MAX_DISPLAY_NAME}" style="width:100%;padding:12px;margin-bottom:12px;border:1px solid #ddd;border-radius:8px">
          <textarea placeholder="Bio (optional)" id="profileBio" style="width:100%;padding:12px;margin-bottom:12px;border:1px solid #ddd;border-radius:8px;min-height:80px;resize:vertical">${(prof.bio||'').replace(/</g,'&lt;')}</textarea>
          <div style="display:flex;gap:16px;margin-bottom:16px;color:#666;font-size:0.9rem"><span>📝 ${myReviews} reviews</span><span>🔖 ${state.saved.length} saved</span></div>
          <button onclick="saveProfile()" style="padding:12px 24px;background:#e31919;color:white;border:none;border-radius:8px;cursor:pointer">Save</button>
          <button onclick="state.panel='main'; render()" style="padding:12px 24px;background:#666;color:white;border:none;border-radius:8px;cursor:pointer;margin-left:8px">Cancel</button>
        </div></div>`;
      } else if (state.panel === 'saved') {
        const savedReviews = state.reviews.filter(r => isSaved(r));
        const listName = (state.savedListFilter || 'Saved');
        const getReviewsForList = (name) => {
          if (name === 'Saved') return state.reviews.filter(r => isSaved(r));
          const keys = state.groupLists[name] || [];
          return state.reviews.filter(r => keys.includes(getSavedKey(r)));
        };
        const listCounts = { Saved: savedReviews.length };
        GROUP_LIST_NAMES.filter(n=>n!=='Saved').forEach(n => { listCounts[n] = (state.groupLists[n]||[]).length; });
        mainContent = `<div class="main">
          <div style="margin-bottom:12px"><button onclick="state.panel='main'; state.tab='feed'; render()" style="padding:8px 16px;background:#e31919;color:white;border:none;border-radius:8px;cursor:pointer">← Back</button></div>
          <h2 style="margin-bottom:16px">Lists</h2>
          <div style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:16px">
            ${GROUP_LIST_NAMES.map(name=>`<button onclick="state.savedListFilter='${name}'; render()" style="padding:8px 14px;border-radius:8px;border:1px solid #ddd;background:${listName===name?'#e31919':''};color:${listName===name?'white':'#333'};cursor:pointer;font-size:0.9rem">${name} (${listCounts[name]||0})</button>`).join('')}
          </div>
          <h3 style="margin-bottom:12px">${listName} (${getReviewsForList(listName).length})</h3>
          ${getReviewsForList(listName).length ? getReviewsForList(listName).map(r=>renderReviewCard(r)).join('') : '<p style="color:#666">No restaurants in this list yet. Use the List button on reviews to add.</p>'}
        </div>`;
      } else if (state.panel === 'network') {
        if (window.FOODIE_API?.enabled && !state._suggestedUsersFetched) loadSuggestedUsers();
        const pendingForMe = getPendingRequestsForMe();
        const peopleToAdd = getPeopleYouCanAdd();
        const peopleYouMightKnow = getPeopleYouMightKnow();
        const conns = state.connections[state.user?.displayName] || [];
        const suggestedSection = (window.FOODIE_API?.enabled && (conns.length === 0 || state.suggestedUsers.length > 0)) ? `
          <h3 style="margin-bottom:8px;font-size:1rem;color:#333">People on Foodie</h3>
          <p style="font-size:0.85rem;color:#666;margin-bottom:12px">Others who use the app. Connect to see their reviews.</p>
          ${state.suggestedUsersLoading ? '<p style="color:#666;padding:16px;background:#f9f9f9;border-radius:8px;margin-bottom:24px">Loading...</p>' : state.suggestedUsers.length ? `<div style="margin-bottom:24px">${state.suggestedUsers.map(p=>{
            const av = p.avatarUrl && isSafePhotoUrl(p.avatarUrl) ? p.avatarUrl : '';
            return `<div class="network-card" style="display:flex;align-items:center;justify-content:space-between;padding:16px;background:white;border-radius:8px;margin-bottom:8px;box-shadow:0 1px 3px rgba(0,0,0,0.08)">
              <div style="display:flex;align-items:center;gap:12px">
                <div class="review-avatar" style="width:48px;height:48px;font-size:1rem${av?';background-image:url('+av+');background-size:cover;background-position:center':''}">${av?'':getInitials(p.displayName)}</div>
                <div style="font-weight:600">${escapeHtml(p.displayName)}</div>
              </div>
              <button onclick="connectFromSearch('${(p.displayName||'').replace(/'/g,"\\'")}')" style="padding:8px 16px;background:#0a66c2;color:white;border:none;border-radius:8px;cursor:pointer;font-weight:500">Connect</button>
            </div>`;
          }).join('')}</div>` : '<p style="color:#666;padding:16px;background:#f9f9f9;border-radius:8px;margin-bottom:24px">No one else on Foodie yet. Invite friends to join!</p>'}
        ` : '';
        mainContent = `<div class="main">
          <div style="margin-bottom:12px"><button onclick="state.panel='main'; state.tab='feed'; render()" style="padding:8px 16px;background:#e31919;color:white;border:none;border-radius:8px;cursor:pointer">← Back</button></div>
          <h2 style="margin-bottom:20px">Network</h2>
          <p style="font-size:0.9rem;color:#666;margin-bottom:16px">Connect with people you know to see their restaurant reviews.</p>
          <h3 style="margin-bottom:8px;font-size:1rem;color:#333">Invite friends not on Foodie</h3>
          <p style="font-size:0.85rem;color:#666;margin-bottom:12px">Share a link via WhatsApp, Messages, or email. When they sign up, you&apos;re connected instantly. If someone forwards your link, you can remove them in Network.</p>
          <button onclick="shareApp(true)" style="display:flex;align-items:center;justify-content:center;gap:8px;width:100%;padding:14px 20px;margin-bottom:12px;background:#0a66c2;color:white;border:none;border-radius:8px;cursor:pointer;font-size:1rem;font-weight:500">📤 Invite via link</button>
          ${suggestedSection}
          ${window.FOODIE_API?.enabled ? `<h3 style="margin-bottom:8px;font-size:1rem;color:#333">Search people on Foodie</h3>
          <p style="font-size:0.85rem;color:#666;margin-bottom:12px">Search by name (min 2 characters). Results update as you type.</p>
          <div style="margin-bottom:16px">
            <input type="text" id="networkSearchInput" placeholder="Search by name (min 2 chars)..." autocomplete="off" value="${(state.networkSearch||'').replace(/"/g,'&quot;')}" oninput="state.networkSearch=this.value; onNetworkSearchInput()" style="width:100%;padding:12px 16px;border:1px solid #ddd;border-radius:8px;font-size:1rem">
          </div>
          ${(state.networkSearch||'').trim().length >= 2 ? (state.networkSearchLoading ? '<p style="color:#666;padding:16px;background:#f9f9f9;border-radius:8px;margin-bottom:24px">Searching...</p>' : state.networkSearchResults.length ? `<div style="margin-bottom:24px">${state.networkSearchResults.map(p=>{
            const av = p.avatarUrl && isSafePhotoUrl(p.avatarUrl) ? p.avatarUrl : '';
            return `<div class="network-card" style="display:flex;align-items:center;justify-content:space-between;padding:16px;background:white;border-radius:8px;margin-bottom:8px;box-shadow:0 1px 3px rgba(0,0,0,0.08)">
              <div style="display:flex;align-items:center;gap:12px">
                <div class="review-avatar" style="width:48px;height:48px;font-size:1rem${av?';background-image:url('+av+');background-size:cover;background-position:center':''}">${av?'':getInitials(p.displayName)}</div>
                <div style="font-weight:600">${escapeHtml(p.displayName)}</div>
              </div>
              <button onclick="connectFromSearch('${(p.displayName||'').replace(/'/g,"\\'")}')" style="padding:8px 16px;background:#0a66c2;color:white;border:none;border-radius:8px;cursor:pointer;font-weight:500">Connect</button>
            </div>`;
          }).join('')}</div>` : '<p style="color:#666;padding:16px;background:#f9f9f9;border-radius:8px;margin-bottom:24px">No results. Try a different name.</p>') : ''}` : `<h3 style="margin-bottom:8px;font-size:1rem;color:#333">Connect with someone</h3>
          <p style="font-size:0.85rem;color:#666;margin-bottom:8px">Type their display name to send a connection request.</p>
          <div style="display:flex;gap:8px;margin-bottom:24px;flex-wrap:wrap">
            <input type="text" id="inviteNameInput" placeholder="e.g. John, Priya Sharma" value="${(state.addConnectionInput||'').replace(/"/g,'&quot;')}" oninput="state.addConnectionInput=this.value" style="flex:1;min-width:180px;padding:12px 16px;border:1px solid #ddd;border-radius:8px;font-size:1rem">
            <button onclick="var n=document.getElementById('inviteNameInput')?.value?.trim(); if(n){sendConnectionRequest(n); state.addConnectionInput=''; if(n)document.getElementById('inviteNameInput').value=''; render()}" style="padding:12px 20px;background:#0a66c2;color:white;border:none;border-radius:8px;cursor:pointer;font-weight:500">Send request</button>
          </div>`}
          ${pendingForMe.length ? `
          <h3 style="margin-bottom:12px;font-size:1rem;color:#333">Invitations (${pendingForMe.length})</h3>
          <p style="font-size:0.9rem;color:#666;margin-bottom:12px">These people want to connect with you. Approve to add them to your network.</p>
          <div style="margin-bottom:24px">${pendingForMe.map(r=>`
            <div class="network-card" style="display:flex;align-items:center;justify-content:space-between;padding:16px;background:white;border-radius:8px;margin-bottom:8px;box-shadow:0 1px 3px rgba(0,0,0,0.08)">
              <div style="display:flex;align-items:center;gap:12px">
                <div class="review-avatar" style="width:48px;height:48px;font-size:1rem">${getInitials(r.from)}</div>
                <div>
                  <div style="font-weight:600">${escapeHtml(r.from)}</div>
                  <div style="font-size:0.8rem;color:#666">Wants to connect</div>
                </div>
              </div>
              <div style="display:flex;gap:8px">
                <button onclick="acceptConnectionRequest('${r.id}'); render()" style="padding:8px 16px;background:#0a66c2;color:white;border:none;border-radius:8px;cursor:pointer;font-weight:500">Accept</button>
                <button onclick="ignoreConnectionRequest('${r.id}'); render()" style="padding:8px 16px;background:#eee;color:#333;border:none;border-radius:8px;cursor:pointer">Ignore</button>
              </div>
            </div>
          `).join('')}</div>
          ` : ''}
          ${peopleYouMightKnow.length ? `
          <h3 style="margin-bottom:12px;font-size:1rem;color:#333">People you might know</h3>
          <p style="font-size:0.9rem;color:#666;margin-bottom:12px">Friends of your connections. Connect to see their reviews.</p>
          <div style="margin-bottom:24px">${peopleYouMightKnow.map(p=>`
            <div class="network-card" style="display:flex;align-items:center;justify-content:space-between;padding:16px;background:white;border-radius:8px;margin-bottom:8px;box-shadow:0 1px 3px rgba(0,0,0,0.08)">
              <div style="display:flex;align-items:center;gap:12px">
                <div class="review-avatar" style="width:48px;height:48px;font-size:1rem">${getInitials(p.name)}</div>
                <div>
                  <div style="font-weight:600">${escapeHtml(p.name)}</div>
                  ${p.mutual ? `<div style="font-size:0.8rem;color:#0a66c2">${p.mutual} mutual connection${p.mutual>1?'s':''}</div>` : ''}
                </div>
              </div>
              <button onclick="sendConnectionRequest('${(p.name||'').replace(/'/g,"\\'")}'); render()" style="padding:8px 16px;background:#0a66c2;color:white;border:none;border-radius:8px;cursor:pointer;font-weight:500">Connect</button>
            </div>
          `).join('')}</div>
          ` : ''}
          ${(getPendingRequestsFromMe()).length ? `
          <h3 style="margin-bottom:12px;font-size:1rem;color:#333">Pending (sent)</h3>
          <p style="font-size:0.9rem;color:#666;margin-bottom:12px">Waiting for these people to approve your request. Cancel if they haven't responded.</p>
          <div style="margin-bottom:24px">${getPendingRequestsFromMe().map(r=>`
            <div style="display:flex;align-items:center;justify-content:space-between;padding:12px;background:#f9f9f9;border-radius:8px;margin-bottom:8px">
              <span>${escapeHtml(r.to)}</span>
              <button onclick="cancelConnectionRequest('${r.id}'); render()" style="padding:6px 12px;background:#999;color:white;border:none;border-radius:6px;cursor:pointer;font-size:0.85rem">Cancel</button>
            </div>
          `).join('')}</div>
          ` : ''}
          <h3 style="margin-bottom:12px;font-size:1rem;color:#333">Add from reviews</h3>
          <p style="font-size:0.9rem;color:#666;margin-bottom:12px">People who have reviewed restaurants. Connect to see their full feed.</p>
          <div style="margin-bottom:24px">${peopleToAdd.length ? peopleToAdd.map(u=>`
            <div class="network-card" style="display:flex;align-items:center;justify-content:space-between;padding:16px;background:white;border-radius:8px;margin-bottom:8px;box-shadow:0 1px 3px rgba(0,0,0,0.08)">
              <div style="display:flex;align-items:center;gap:12px">
                <div class="review-avatar" style="width:48px;height:48px;font-size:1rem">${getInitials(u)}</div>
                <div style="font-weight:600">${escapeHtml(u)}</div>
              </div>
              <button onclick="sendConnectionRequest('${(u||'').replace(/'/g,"\\'")}'); render()" style="padding:8px 16px;background:#0a66c2;color:white;border:none;border-radius:8px;cursor:pointer;font-weight:500">Connect</button>
            </div>
          `).join('') : '<p style="color:#666;padding:16px;background:#f9f9f9;border-radius:8px">No one to add from reviews right now.</p>'}</div>
          <h3 style="margin-bottom:12px;font-size:1rem;color:#333">Your connections (${conns.length})</h3>
          <div>${conns.length ? conns.map(c=>`<div style="display:flex;justify-content:space-between;align-items:center;padding:12px;background:white;border-radius:8px;margin-bottom:8px;box-shadow:0 1px 2px rgba(0,0,0,0.06)"><span>${escapeHtml(c)}</span><button onclick="removeConnection('${(c||'').replace(/'/g,"\\'")}'); render()" style="padding:6px 12px;background:#e31919;color:white;border:none;border-radius:6px;cursor:pointer;font-size:0.85rem">Remove</button></div>`).join('') : '<p style="color:#666">No connections yet. Invite people above or connect from reviews.</p>'}</div>
        </div>`;
      } else if (state.panel === 'notifications') {
        const notifs = state.notifications.filter(n => !n.recipient || n.recipient === state.user?.displayName).slice().reverse();
        mainContent = `<div class="main">
          <div style="margin-bottom:12px"><button onclick="state.panel='main'; state.tab='feed'; render()" style="padding:8px 16px;background:#e31919;color:white;border:none;border-radius:8px;cursor:pointer">← Back</button></div>
          <h2 style="margin-bottom:16px">Notifications</h2>
          ${notifs.length ? notifs.map(n=>`<div style="padding:12px;background:white;border-radius:8px;margin-bottom:8px;${n.read?'opacity:0.7':''}${n.type==='connection_request'?'cursor:pointer':''}" ${n.type==='connection_request'?'onclick="state.panel=\'network\'; render()"':''}>${escapeHtml(n.text)}${n.type==='connection_request'?' — Tap to view in Network':''}</div>`).join('') + `<button onclick="state.notifications.forEach(n=>{if(!n.recipient||n.recipient===state.user?.displayName)n.read=true}); saveToStorage(); render()" style="margin-top:12px;padding:8px 16px;background:#666;color:white;border:none;border-radius:8px;cursor:pointer">Mark all read</button>` : '<p style="color:#666">No notifications yet.</p>'}
        </div>`;
      } else if (state.panel === 'restaurant' && state.viewRestaurant) {
        const vr = state.viewRestaurant;
        const vrLat = parseFloat(vr.lat), vrLng = parseFloat(vr.lng);
        const restReviews = state.reviews.filter(r => Math.abs(parseFloat(r.lat) - vrLat) < 0.001 && Math.abs(parseFloat(r.lng) - vrLng) < 0.001);
        const networkScore = getRestaurantNetworkScore(vr.lat, vr.lng);
        const cuisines = [...new Set(restReviews.map(r=>r.cuisine||'Various'))];
        const looksWrong = Math.abs(vr.lat - 37.37) < 0.1 && Math.abs(vr.lng - (-122.03)) < 0.1;
        const hasOwnReview = restReviews.some(r => r.by === state.user?.displayName);
        mainContent = `<div class="main">
          <div style="margin-bottom:12px"><button onclick="state.panel='main'; state.tab='feed'; state.viewRestaurant=null; render()" style="padding:8px 16px;background:#e31919;color:white;border:none;border-radius:8px;cursor:pointer">← Back</button></div>
          <div style="padding:20px;background:white;border-radius:12px;margin-bottom:16px">
            <h1 style="font-size:1.5rem;margin-bottom:8px">${escapeHtml(vr.name)}</h1>
            <div style="display:flex;gap:16px;flex-wrap:wrap;color:#666;font-size:0.95rem">
              ${networkScore ? `<span style="font-weight:500;color:#333">Network: ${networkScore.avgRating} ★ (${networkScore.count} ${networkScore.count===1?'review':'reviews'})</span>` : ''}
              ${cuisines.length ? `<span>${cuisines.join(', ')}</span>` : ''}
            </div>
            <div style="display:flex;gap:12px;flex-wrap:wrap;margin-top:12px;align-items:center">
              <a href="https://www.google.com/maps?q=${vr.lat},${vr.lng}" target="_blank" rel="noopener" style="color:#0a66c2;font-size:0.9rem">📍 Get directions</a>
              <button onclick="goToMapFromViewRestaurant()" style="padding:6px 12px;background:#e31919;color:white;border:none;border-radius:6px;cursor:pointer;font-size:0.9rem">📍 View on map</button>
              <button onclick="openFixLocationModal('${(vr.name||'').replace(/'/g,"\\'")}', ${vr.lat}, ${vr.lng})" style="padding:6px 12px;background:#333;color:white;border:none;border-radius:6px;cursor:pointer;font-size:0.9rem">🔧 Fix location</button>
            </div>
          </div>
          <h3 style="margin-bottom:12px">Reviews</h3>
          ${restReviews.length ? restReviews.map(r=>renderReviewCard(r)).join('') : '<p style="color:#666">No reviews yet.</p>'}
        </div>`;
      } else if (state.panel === 'groups' && window.FOODIE_API?.enabled) {
        const groups = state.groups || [];
        if (state.groupsPanel === 'create') {
          const conns = state.connections[state.user?.displayName] || [];
          const addable = conns.filter(c => !state.createGroupMembers.includes(c));
          mainContent = `<div class="main">
          <div style="margin-bottom:12px"><button onclick="state.groupsPanel='list'; state.createGroupName=''; state.createGroupMembers=[]; render()" style="padding:8px 16px;background:#e31919;color:white;border:none;border-radius:8px;cursor:pointer">← Back</button></div>
          <h2 style="margin-bottom:20px">Create group</h2>
          <p style="font-size:0.9rem;color:#666;margin-bottom:16px">Private, invite-only groups. Only members can see the group and its feed.</p>
          <div style="margin-bottom:16px">
            <label style="font-size:0.9rem;color:#666;display:block;margin-bottom:6px">Group name</label>
            <input type="text" id="createGroupNameInput" placeholder="e.g. Foodie Squad" value="${(state.createGroupName||'').replace(/"/g,'&quot;')}" oninput="state.createGroupName=this.value" style="width:100%;padding:12px 16px;border:1px solid #ddd;border-radius:8px;font-size:1rem">
          </div>
          <h3 style="margin-bottom:12px;font-size:1rem">Add members (from your connections)</h3>
          <div style="margin-bottom:16px;display:flex;flex-wrap:wrap;gap:8px">${(state.createGroupMembers||[]).map(n=>`<span style="display:inline-flex;align-items:center;gap:6px;padding:8px 12px;background:#e31919;color:white;border-radius:8px;font-size:0.9rem">${escapeHtml(n)} <button onclick="state.createGroupMembers=state.createGroupMembers.filter(x=>x!=='${(n||'').replace(/'/g,"\\'")}'); render()" style="background:none;border:none;color:white;cursor:pointer;font-size:1.1rem;line-height:1">×</button></span>`).join('')}</div>
          <div style="display:flex;flex-wrap:wrap;gap:8px;margin-bottom:24px">${addable.length ? addable.map(c=>`<button onclick="state.createGroupMembers=[...(state.createGroupMembers||[]),'${(c||'').replace(/'/g,"\\'")}']; render()" style="padding:8px 16px;background:#0a66c2;color:white;border:none;border-radius:8px;cursor:pointer;font-size:0.9rem">+ ${escapeHtml(c)}</button>`).join('') : '<p style="color:#666;font-size:0.9rem">No connections to add. Connect with people first in Network.</p>'}</div>
          <button onclick="createGroup()" style="padding:14px 24px;background:#e31919;color:white;border:none;border-radius:8px;cursor:pointer;font-weight:600;font-size:1rem">Create group</button>
        </div>`;
        } else if (state.groupsPanel === 'detail' && state.selectedGroupId) {
          const g = groups.find(x => x.id === state.selectedGroupId);
          if (g) {
            const groupReviews = state.reviews.filter(r => g.memberNames.includes(r.by));
            const isCreator = g.createdBy === state.user?.displayName;
            const conns = state.connections[state.user?.displayName] || [];
            const addable = conns.filter(c => !g.memberNames.includes(c));
            mainContent = `<div class="main">
          <div style="margin-bottom:12px"><button onclick="state.groupsPanel='list'; state.selectedGroupId=null; render()" style="padding:8px 16px;background:#e31919;color:white;border:none;border-radius:8px;cursor:pointer">← Back</button></div>
          <h2 style="margin-bottom:8px">${escapeHtml(g.name)}</h2>
          <p style="font-size:0.9rem;color:#666;margin-bottom:16px">Created by ${escapeHtml(g.createdBy)} · ${g.memberNames.length} member${g.memberNames.length!==1?'s':''}</p>
          <div style="display:flex;flex-wrap:wrap;gap:8px;margin-bottom:16px">${g.memberNames.map(n=>`<span style="display:inline-flex;align-items:center;gap:6px;padding:8px 12px;background:#f3f2ef;border-radius:8px;font-size:0.9rem">${escapeHtml(n)}${isCreator && n!==state.user?.displayName ? `<button onclick="removeMemberFromGroup('${g.id}','${(n||'').replace(/'/g,"\\'")}'); render()" style="background:none;border:none;color:#666;cursor:pointer;font-size:1rem;line-height:1">×</button>` : ''}</span>`).join('')}</div>
          ${isCreator && addable.length ? `<div style="margin-bottom:16px"><label style="font-size:0.9rem;color:#666;display:block;margin-bottom:6px">Add member</label><div style="display:flex;flex-wrap:wrap;gap:8px">${addable.map(c=>`<button onclick="addMemberToGroup('${g.id}','${(c||'').replace(/'/g,"\\'")}'); render()" style="padding:8px 16px;background:#0a66c2;color:white;border:none;border-radius:8px;cursor:pointer;font-size:0.9rem">+ ${escapeHtml(c)}</button>`).join('')}</div></div>` : ''}
          ${isCreator ? `<button onclick="deleteGroupConfirm('${g.id}')" style="padding:8px 16px;background:#c62828;color:white;border:none;border-radius:8px;cursor:pointer;font-size:0.9rem;margin-bottom:16px">Delete group</button>` : `<button onclick="leaveGroupConfirm('${g.id}')" style="padding:8px 16px;background:#666;color:white;border:none;border-radius:8px;cursor:pointer;font-size:0.9rem;margin-bottom:16px">Leave group</button>`}
          <h3 style="margin-bottom:12px">Group feed (${groupReviews.length})</h3>
          ${groupReviews.length ? groupReviews.map(r=>renderReviewCard(r)).join('') : '<p style="color:#666">No reviews from group members yet.</p>'}
        </div>`;
          } else {
            mainContent = `<div class="main"><div style="margin-bottom:12px"><button onclick="state.groupsPanel='list'; state.selectedGroupId=null; render()" style="padding:8px 16px;background:#e31919;color:white;border:none;border-radius:8px;cursor:pointer">← Back</button></div><p style="color:#666">Group not found.</p></div>`;
          }
        } else {
          mainContent = `<div class="main">
          <div style="margin-bottom:12px"><button onclick="state.panel='main'; state.tab='feed'; render()" style="padding:8px 16px;background:#e31919;color:white;border:none;border-radius:8px;cursor:pointer">← Back</button></div>
          <h2 style="margin-bottom:20px;display:flex;align-items:center;gap:12px;flex-wrap:wrap">Groups <button onclick="state._groupsRetryScheduled=false; refreshFeed()" title="Refresh groups" style="padding:8px 12px;background:#e31919;color:white;border:none;border-radius:8px;cursor:pointer;font-size:0.9rem">↻ Refresh</button></h2>
          <p style="font-size:0.9rem;color:#666;margin-bottom:16px">Private, invite-only groups. Create a group and add connections to share a smaller feed and map.</p>
          <button onclick="state.groupsPanel='create'; state.createGroupName=''; state.createGroupMembers=[]; render()" style="width:100%;padding:14px 20px;margin-bottom:24px;background:#0a66c2;color:white;border:none;border-radius:8px;cursor:pointer;font-size:1rem;font-weight:500">+ Create group</button>
          ${groups.length ? groups.map(g=>`<div onclick="state.selectedGroupId='${g.id}'; state.groupsPanel='detail'; render()" style="padding:16px;background:white;border-radius:8px;margin-bottom:8px;box-shadow:0 1px 3px rgba(0,0,0,0.08);cursor:pointer"><div style="font-weight:600">${escapeHtml(g.name)}</div><div style="font-size:0.85rem;color:#666;margin-top:4px">${g.memberNames.length} member${g.memberNames.length!==1?'s':''} · by ${escapeHtml(g.createdBy)}</div></div>`).join('') : '<p style="color:#666">No groups yet. Create one to get started.</p>'}
        </div>`;
        }
      } else if (state.panel === 'feedback') {
        mainContent = `<div class="main"><div style="padding:16px;background:white;border-radius:8px;max-width:400px;margin:0 auto">
          <h2 style="margin-bottom:16px">Feedback</h2>
          <textarea id="feedbackText" placeholder="Share your feedback..." style="width:100%;padding:12px;margin-bottom:12px;border:1px solid #ddd;border-radius:8px;min-height:100px"></textarea>
          <button onclick="alert('Thanks! Feedback submitted.'); state.panel='main'; render()" style="padding:12px 24px;background:#e31919;color:white;border:none;border-radius:8px;cursor:pointer">Submit</button>
          <button onclick="state.panel='main'; render()" style="padding:12px 24px;background:#666;color:white;border:none;border-radius:8px;cursor:pointer;margin-left:8px">Cancel</button>
        </div></div>`;
      } else if (state.tab === 'feed' || state.panel === 'myreviews') {
        mainContent = '<div class="main">' +
          (state.panel === 'myreviews' ? `<div style="margin-bottom:12px;display:flex;align-items:center;gap:12px"><button onclick="state.panel='main'; state.tab='feed'; render()" style="padding:8px 16px;background:#e31919;color:white;border:none;border-radius:8px;cursor:pointer">← Back</button><span style="font-size:0.95rem;color:#666">${reviews.length} review${reviews.length===1?'':'s'}</span></div>` : '') +
          (state.panel === 'main' ? `<div class="feed-search" style="display:flex;gap:8px;align-items:center"><input type="text" id="feedSearchInput" placeholder="Search reviews, restaurants, or people..." value="${(state.feedSearch||'').replace(/"/g,'&quot;')}" oninput="state.feedSearch=this.value; updateFeedCards()" style="flex:1">${window.FOODIE_API?.enabled ? `<button onclick="refreshFeed()" title="Refresh from server" style="padding:10px;background:#e31919;color:white;border:none;border-radius:8px;cursor:pointer;font-size:1.1rem">↻</button>` : ''}</div>
            <div id="feedStats" style="font-size:0.9rem;color:#666;margin-bottom:12px">${(()=>{const list=getFilteredReviews();const c=state._feedLevelCounts||{};const l1=c.l1||0;const l2=c.l2||0;const l3=c.l3||0;const total=list.length;const lev=state.feedLevelFilter;return total+' reviews'+(total?' · <a href="#" onclick="event.preventDefault();state.feedLevelFilter=state.feedLevelFilter===\'1\'?\'\':\'1\';updateFeedCards();render();return false" style="color:'+(lev==='1'?'#e31919':'#006CE0')+';text-decoration:underline;cursor:pointer">1st: '+l1+'</a> · <a href="#" onclick="event.preventDefault();state.feedLevelFilter=state.feedLevelFilter===\'2\'?\'\':\'2\';updateFeedCards();render();return false" style="color:'+(lev==='2'?'#e31919':'#FF8D00')+';text-decoration:underline;cursor:pointer">2nd: '+l2+'</a>'+(l3?' · <a href="#" onclick="event.preventDefault();state.feedLevelFilter=state.feedLevelFilter===\'3\'?\'\':\'3\';updateFeedCards();render();return false" style="color:'+(lev==='3'?'#e31919':'#333')+';text-decoration:underline;cursor:pointer">Yours: '+l3+'</a>':'')+'':'');})()}</div>
            ${window.FOODIE_API?.enabled ? `<button onclick="setTab('groups')" style="margin-bottom:12px;padding:8px 16px;background:#0a66c2;color:white;border:none;border-radius:8px;cursor:pointer;font-size:0.9rem;font-weight:500">👥 Groups ${(state.groups||[]).length ? '('+(state.groups||[]).length+')' : ''}</button>` : ''}
            <div class="feed-filters">
              <select onchange="state.feedCuisine=this.value; updateFeedCards()" style="padding:8px;border-radius:8px;border:1px solid #ddd;font-size:0.9rem">
                <option value="">All cuisines</option>${CUISINES.map(c=>`<option value="${c}" ${state.feedCuisine===c?'selected':''}>${c}</option>`).join('')}
              </select>
              <select onchange="state.feedPrice=this.value; updateFeedCards()" style="padding:8px;border-radius:8px;border:1px solid #ddd;font-size:0.9rem">
                <option value="">Any price</option>${[1,2,3,4].map(p=>`<option value="${p}" ${state.feedPrice==p?'selected':''}>Up to ${PRICE_LABELS[p-1]}</option>`).join('')}
              </select>
              <select onchange="state.feedMinRating=this.value; updateFeedCards()" style="padding:8px;border-radius:8px;border:1px solid #ddd;font-size:0.9rem">
                <option value="0">Any rating</option>${[4,5].map(r=>`<option value="${r}" ${state.feedMinRating==r?'selected':''}>${r}+ stars</option>`).join('')}
              </select>
            </div>` : '') +
          (state.panel === 'main' ? `<div class="feed-compose" onclick="setTab('add')">
            <div class="feed-compose-avatar">${getInitials(state.user.displayName)}</div>
            <span class="feed-compose-text">Share a restaurant review</span>
          </div>` : '') +
          (state.panel === 'main' && reviews.length === 0 && (state.connections[state.user?.displayName] || []).length === 0 ? `
          <div class="empty-feed-card" style="padding:24px;background:linear-gradient(135deg,#f8f9fa 0%,#e9ecef 100%);border-radius:12px;margin-bottom:16px;border:1px solid #dee2e6">
            <h3 style="margin:0 0 12px 0;font-size:1.2rem;color:#333">Get started</h3>
            <p style="margin:0 0 16px 0;font-size:0.95rem;color:#666;line-height:1.5">Your feed is empty. Connect with people to see their restaurant reviews.</p>
            <p style="margin:0 0 16px 0;font-size:0.9rem;color:#555"><strong>How to connect:</strong></p>
            <ul style="margin:0 0 16px 0;padding-left:20px;font-size:0.9rem;color:#555;line-height:1.6">
              <li><strong>People on Foodie</strong> — Go to Network to see others who use the app</li>
              <li><strong>Invite friends</strong> — Share your link; when they sign up, you&apos;re connected instantly (no approval needed)</li>
              <li><strong>Search by name</strong> — If someone is already on Foodie, search for them in Network</li>
            </ul>
            <button onclick="setTab('network'); state.panel='network'; render()" style="padding:12px 24px;background:#0a66c2;color:white;border:none;border-radius:8px;cursor:pointer;font-weight:600;font-size:1rem">Go to Network →</button>
          </div>
          ` : '') +
          `<div id="feedCards">` + reviews.map(r => renderReviewCard(r)).join('') + '</div></div>';
      } else if (state.tab === 'add' && state.panel === 'main') {
        const isEditing = !!state.editingReview;
        mainContent = `
          <div class="main add-review-page">
            <div style="position:relative">
              <input type="text" class="add-review-input" id="addReviewRestaurantInput" placeholder="${isEditing ? 'Change restaurant or address' : 'Restaurant name or address (optional: pick from suggestions)'}" 
                value="${(state.restaurantSearch||'').replace(/"/g,'&quot;')}" 
                oninput="state.restaurantSearch=this.value; searchRestaurants(this.value)" onfocus="requestUserLocationIfNeeded()" onblur="setTimeout(function(){state.searchResults=[];updateAddReviewSearchResults();},150)">
              <div id="addReviewSearchResults" class="search-results" style="display:${state.searchResults.length?'block':'none'}">
                ${state.restaurantSearch.trim() && state.searchResults.length ? `<div class="search-result-item" style="font-weight:600;color:#0a66c2" onclick="useTypedNameAsPlace()">✓ Use &quot;${escapeHtml(state.restaurantSearch.trim().slice(0,40))}${state.restaurantSearch.trim().length>40?'...':''}&quot; as entered</div>` : ''}
                ${state.searchResults.map((p, i) => `
                <div class="search-result-item" onclick="selectPlaceByIndex(${i})">${escapeHtml(p.name)}</div>
              `).join('')}
                ${state.restaurantSearch.trim() ? `<div class="search-result-item" style="color:#0a66c2;border-top:1px solid #eee;margin-top:4px;padding-top:8px" onclick="state.pickOnMapRestaurantName=document.getElementById('addReviewRestaurantInput')?.value?.trim()||state.restaurantSearch?.trim()||''; setTab('map'); render()">📍 Can&apos;t find it? Pin on map</div>` : ''}</div>
            </div>
            <p style="font-size:0.85rem;color:#666;margin:-8px 0 0 0">Type a name or pick from suggestions. Either works.</p>
            <div class="add-review-rating">
              <span>Rating</span>
              <div class="rating-hearts">
                ${[1,2,3,4,5].map(i => `<button type="button" class="heart ${state.rating>=i?'active':''}" onclick="setRating(${i})">❤️</button>`).join('')}
              </div>
            </div>
            <div class="add-review-meta">
              <select id="addCuisine" onchange="state.addCuisine=this.value; render()" style="padding:10px;border-radius:8px;border:1px solid #ddd;flex:1">
                <option value="">Cuisine (optional)</option>
                ${CUISINES.map(c => `<option value="${c}" ${state.addCuisine===c?'selected':''}>${c}</option>`).join('')}
              </select>
              <select id="addPrice" onchange="state.addPrice=+this.value; render()" style="padding:10px;border-radius:8px;border:1px solid #ddd;flex:1">
                ${[1,2,3,4].map(p => `<option value="${p}" ${state.addPrice===p?'selected':''}>${PRICE_LABELS[p-1]} Price</option>`).join('')}
              </select>
            </div>
            <div style="display:flex;gap:16px;flex-wrap:wrap;margin-bottom:12px">
              <label style="display:flex;align-items:center;gap:8px;cursor:pointer;font-size:0.95rem"><input type="checkbox" ${state.addVerifiedVisit?'checked':''} onchange="state.addVerifiedVisit=this.checked; render()"> ✓ Verified visit</label>
              <label style="display:flex;align-items:center;gap:8px;cursor:pointer;font-size:0.95rem"><input type="checkbox" ${state.addWouldGoAgain?'checked':''} onchange="state.addWouldGoAgain=this.checked; render()"> 🔄 Would go again</label>
            </div>
            <div class="add-review-photos">
              <div class="photo-add-sheet">
                <button type="button" class="photo-upload-btn" onclick="togglePhotoAddSheet()">📷 Add photos</button>
                <div class="photo-add-sheet-backdrop" id="photoAddBackdrop" onclick="closePhotoAddSheet()"></div>
                <div class="photo-add-sheet-menu" id="photoAddMenu">
                  <button type="button" class="photo-add-sheet-item" onclick="openCameraCapture(event)">📷 Take Photo</button>
                  <button type="button" class="photo-add-sheet-item" onclick="document.getElementById('photoInputLibrary').click(); closePhotoAddSheet()">🖼️ Choose from Library</button>
                </div>
                <input type="file" id="photoInputCamera" accept="image/*" capture="user" onchange="handlePhotoUpload(this)" style="display:none">
                <input type="file" id="photoInputLibrary" accept="image/*" multiple onchange="handlePhotoUpload(this)" style="display:none">
              </div>
              ${(state.addPhotos||[]).map((p,i)=>isSafePhotoUrl(p)?`<span class="photo-preview"><img src="${p}" alt=""><button type="button" onclick="state.addPhotos.splice(${i},1); render()">×</button></span>`:'').filter(Boolean).join('')}
            </div>
            <textarea class="add-review-textarea" placeholder="Write your review..." maxlength="${MAX_REVIEW_TEXT}" oninput="state.reviewText=this.value">${(state.reviewText||'').replace(/</g,'&lt;')}</textarea>
            <button class="add-review-submit" onclick="addReview()" ${state._addReviewInProgress ? 'disabled' : ''}>${state._addReviewInProgress ? 'Posting...' : (isEditing ? 'Update Review' : 'Post Review')}</button>
            <button class="add-review-cancel" onclick="discardReview()">${isEditing ? 'Cancel' : 'Discard'}</button>
          </div>
        `;
      } else if (state.tab === 'map' && state.panel === 'main') {
        const total = state.reviews.length;
        const l1 = state.reviews.filter(r=>getEffectiveLevel(r)===1).length;
        const l2 = state.reviews.filter(r=>getEffectiveLevel(r)===2).length;
        mainContent = `
          <div class="main">
            ${state.pickOnMapRestaurantName ? `<div style="background:#e3f2fd;padding:12px 16px;border-radius:8px;margin-bottom:12px;display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap"><span style="font-size:0.95rem">📍 Tap on the map where <strong>${escapeHtml(state.pickOnMapRestaurantName.slice(0,50))}${state.pickOnMapRestaurantName.length>50?'...':''}</strong> is located</span><button onclick="state.pickOnMapRestaurantName=null; render()" style="padding:6px 12px;background:#666;color:white;border:none;border-radius:6px;cursor:pointer;font-size:0.9rem">Cancel</button></div>` : ''}
            <div class="map-search" style="display:flex;gap:8px">
              <input type="text" id="mapSearchInput" placeholder="Search restaurant or place (Enter to go to location)" value="${(state.mapSearch||'').replace(/"/g,'&quot;')}" oninput="updateMapSearch()" onkeydown="if(event.key==='Enter'){event.preventDefault();geocodeMapSearch()}">
              <button onclick="geocodeMapSearch()" style="padding:10px 16px;background:#0a66c2;color:white;border:none;border-radius:8px;cursor:pointer;white-space:nowrap">Go</button>
            </div>
            <div class="map-filters">
              <button class="filter-btn ${state.mapFilter==='all'?'filter-active':''}" onclick="filterMap('all')">📍 Total (${total})</button>
              <button class="filter-btn ${state.mapFilter==='1'?'filter-active':''}" onclick="filterMap('1')">📍 1st Level (${l1})</button>
              <button class="filter-btn ${state.mapFilter==='2'?'filter-active':''}" onclick="filterMap('2')">📍 2nd Level (${l2})</button>
            </div>
            <div class="feed-filters" style="margin-top:8px">
              <select onchange="state.mapCuisine=this.value; filterMap(state.mapFilter)" style="padding:8px;border-radius:8px;border:1px solid #ddd">
                <option value="">All cuisines</option>${CUISINES.map(c=>`<option value="${c}" ${state.mapCuisine===c?'selected':''}>${c}</option>`).join('')}
              </select>
              <select onchange="state.mapPrice=this.value; filterMap(state.mapFilter)" style="padding:8px;border-radius:8px;border:1px solid #ddd">
                <option value="">Any price</option>${[1,2,3,4].map(p=>`<option value="${p}" ${state.mapPrice==p?'selected':''}>Up to ${PRICE_LABELS[p-1]}</option>`).join('')}
              </select>
              <select onchange="state.mapMinRating=this.value; filterMap(state.mapFilter)" style="padding:8px;border-radius:8px;border:1px solid #ddd">
                <option value="0">Any rating</option>
                <option value="4" ${state.mapMinRating==4?'selected':''}>4+ stars</option>
                <option value="5" ${state.mapMinRating==5?'selected':''}>5 stars only</option>
              </select>
            </div>
            <p style="font-size:0.85rem;color:#666;margin-bottom:8px">Gray dots = nearby restaurants. Hover for name, click to add a review. Tap 🔄 to refresh.</p>
            <div style="position:relative">
              <div id="map-container"></div>
              <div class="map-controls" id="mapControls">
                <button class="map-control-btn" onclick="myLocationMap()" title="My location">📍</button>
                <button class="map-control-btn" onclick="showListToast('Loading nearby...'); loadPoiMarkers(0)" title="Refresh nearby restaurants">🔄</button>
              </div>
            </div>
            <div class="map-legend">
              <span><span class="map-legend-dot" style="background:#006CE0"></span> 1st level</span>
              <span><span class="map-legend-dot" style="background:#FF8D00"></span> 2nd level</span>
              <span><span class="map-legend-dot" style="background:#888"></span> Nearby (click to add review)</span>
              <span><span class="map-legend-dot" style="background:#e31919"></span> Your review</span>
            </div>
          </div>
        `;
      } else {
        mainContent = '<div class="main"></div>';
      }

      const sidebarHtml = state.user && state.menuOpen ? `
        <div class="menu-overlay" onclick="closeMenu()"></div>
        <div class="menu-sidebar">
          <div class="menu-sidebar-header">
            <div class="menu-sidebar-avatar" style="${getSafeAvatarUrl(state.profiles[state.user.displayName]) ? 'background-image:url('+getSafeAvatarUrl(state.profiles[state.user.displayName])+');background-size:cover;background-position:center' : ''}">${getSafeAvatarUrl(state.profiles[state.user.displayName]) ? '' : getInitials(state.user.displayName)}</div>
            <div class="menu-sidebar-name">${escapeHtml(state.user.displayName || 'User')}</div>
          </div>
          <nav class="menu-sidebar-nav">
            <button class="menu-sidebar-item" onclick="closeMenu(); state.panel='main'; state.tab='feed'; render()">Feed</button>
            <button class="menu-sidebar-item" onclick="closeMenu(); state.panel='editprofile'; render()">Edit Profile</button>
            <button class="menu-sidebar-item" onclick="closeMenu(); state.panel='myreviews'; state.feedLevelFilter=''; render()">My Reviews</button>
            <button class="menu-sidebar-item" onclick="closeMenu(); state.panel='saved'; render()">Saved (${state.saved.length})</button>
            <button class="menu-sidebar-item" onclick="closeMenu(); state.panel='network'; render()">Network ${getPendingRequestsForMe().length ? `(${getPendingRequestsForMe().length})` : ''}</button>
            ${window.FOODIE_API?.enabled ? `<button class="menu-sidebar-item" onclick="closeMenu(); state.panel='groups'; state.groupsPanel='list'; state.selectedGroupId=null; if(state.user)refreshFeed(); render()">Groups (${(state.groups||[]).length})</button>` : ''}
            <button class="menu-sidebar-item" onclick="closeMenu(); state.panel='notifications'; render()">Notifications ${state.notifications.filter(n=>(!n.recipient||n.recipient===state.user?.displayName)&&!n.read).length ? `(${state.notifications.filter(n=>(!n.recipient||n.recipient===state.user?.displayName)&&!n.read).length})` : ''}</button>
            <button class="menu-sidebar-item" onclick="shareApp()">📤 Share app</button>
            <button class="menu-sidebar-item" onclick="closeMenu(); state.panel='feedback'; render()">Feedback</button>
            <button class="menu-sidebar-item" onclick="closeMenu(); logout()">Logout</button>
            <button class="menu-sidebar-item" onclick="closeMenu(); clearAllData()">Clear all data</button>
          </nav>
        </div>
      ` : '';
      const likersModalHtml = state.viewLikersReviewId ? (() => {
        const r = state.reviews.find(x => x.id === state.viewLikersReviewId);
        const likers = (r?.likedBy || []);
        return `<div class="menu-overlay" onclick="closeLikersModal()" style="z-index:150"></div>
        <div style="position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:white;border-radius:12px;box-shadow:0 8px 32px rgba(0,0,0,0.2);max-width:320px;width:90%;max-height:70vh;overflow:auto;z-index:151;padding:20px">
          <h3 style="margin:0 0 16px 0;font-size:1.1rem">Liked by</h3>
          <div style="display:flex;flex-direction:column;gap:8px">${likers.map(n=>{const av=getSafeAvatarUrl(state.profiles[n]);return `<div style="display:flex;align-items:center;gap:10px;padding:10px;background:#f9f9f9;border-radius:8px"><span class="review-avatar" style="width:36px;height:36px;font-size:0.9rem${av?';background-image:url('+av+');background-size:cover;background-position:center' : ''}">${av?'':getInitials(n)}</span><span style="font-weight:500">${escapeHtml(n)}</span></div>`}).join('')}</div>
          <button onclick="closeLikersModal()" style="margin-top:16px;padding:10px 20px;background:#e31919;color:white;border:none;border-radius:8px;cursor:pointer;width:100%">Close</button>
        </div>`;
      })() : '';
      const reviewersModalHtml = state.viewReviewersReviewId ? (() => {
        const r = state.reviews.find(x => x.id === state.viewReviewersReviewId);
        const reviewers = getAlsoReviewedBy(r);
        const atLoc = r ? getReviewsAtLocation(r) : [];
        let body = '';
        if (reviewers.length) {
          body = reviewers.map(n=>{const av=getSafeAvatarUrl(state.profiles[n]);return `<div style="display:flex;align-items:center;gap:10px;padding:10px;background:#f9f9f9;border-radius:8px"><span class="review-avatar" style="width:36px;height:36px;font-size:0.9rem${av?';background-image:url('+av+');background-size:cover;background-position:center' : ''}">${av?'':getInitials(n)}</span><span style="font-weight:500">${escapeHtml(n)}</span></div>`}).join('');
        } else if (atLoc.length >= 2) {
          const byCount = {};
          atLoc.forEach(rev => { byCount[rev.by] = (byCount[rev.by]||0) + 1; });
          const names = Object.keys(byCount);
          body = names.map(n=>{const av=getSafeAvatarUrl(state.profiles[n]);const c=byCount[n];return `<div style="display:flex;align-items:center;gap:10px;padding:10px;background:#f9f9f9;border-radius:8px"><span class="review-avatar" style="width:36px;height:36px;font-size:0.9rem${av?';background-image:url('+av+');background-size:cover;background-position:center' : ''}">${av?'':getInitials(n)}</span><span style="font-weight:500">${escapeHtml(n)}</span>${c>1?` <span style="color:#666;font-size:0.9rem">(${c} reviews)</span>`:''}</div>`}).join('');
        }
        return `<div class="menu-overlay" onclick="closeReviewersModal()" style="z-index:150"></div>
        <div style="position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:white;border-radius:12px;box-shadow:0 8px 32px rgba(0,0,0,0.2);max-width:320px;width:90%;max-height:70vh;overflow:auto;z-index:151;padding:20px">
          <h3 style="margin:0 0 16px 0;font-size:1.1rem">Also reviewed ${escapeHtml(r?.restaurant||'this place')}</h3>
          <div style="display:flex;flex-direction:column;gap:8px">${body}</div>
          <button onclick="closeReviewersModal()" style="margin-top:16px;padding:10px 20px;background:#e31919;color:white;border:none;border-radius:8px;cursor:pointer;width:100%">Close</button>
        </div>`;
      })() : '';
      const fixLocationModalHtml = state.fixLocationModal ? (() => {
        const m = state.fixLocationModal;
        return `<div class="menu-overlay" onclick="closeFixLocationModal()" style="z-index:150"></div>
        <div style="position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:white;border-radius:12px;box-shadow:0 8px 32px rgba(0,0,0,0.2);max-width:400px;width:95%;z-index:151;padding:20px">
          <h3 style="margin:0 0 8px 0;font-size:1.1rem">Set location for ${escapeHtml(m.restaurantName||'').slice(0,40)}</h3>
          <p style="margin:0 0 12px 0;font-size:0.9rem;color:#666">Drag the pin or click on the map to set the correct location.</p>
          <div id="fix-location-map"></div>
          <div style="display:flex;gap:12px;margin-top:16px">
            <button onclick="confirmFixLocationPin()" style="flex:1;padding:12px;background:#e31919;color:white;border:none;border-radius:8px;cursor:pointer;font-weight:500">Confirm</button>
            <button onclick="closeFixLocationModal()" style="flex:1;padding:12px;background:#666;color:white;border:none;border-radius:8px;cursor:pointer">Cancel</button>
          </div>
        </div>`;
      })() : '';
      const savedNetworkSearch = (state.panel === 'network') ? (document.getElementById('networkSearchInput')?.value ?? state.networkSearch ?? '') : null;
      const hadNetworkSearchFocus = document.activeElement?.id === 'networkSearchInput';
      app.innerHTML = `
        <div class="top-bar">
          <div class="header">
            <button class="menu-btn" onclick="openMenu()">☰</button>
            <img src="logo/Foodie_white.svg" alt="Foodie" class="header-logo">
          </div>
          <nav class="tabs">
            <button class="tab ${state.tab==='feed'?'active':''}" onclick="setTab('feed')">📋 Feed</button>
            <button class="tab ${state.tab==='add'?'active':''}" onclick="setTab('add')">➕ Add</button>
            <button class="tab ${state.tab==='network'?'active':''}" onclick="setTab('network')">👥 Network</button>
            ${window.FOODIE_API?.enabled ? `<button class="tab ${state.tab==='groups'?'active':''}" onclick="setTab('groups')">👥 Groups</button>` : ''}
            <button class="tab ${state.tab==='map'?'active':''}" onclick="setTab('map')">📍 Map</button>
          </nav>
        </div>
        ${sidebarHtml}
        ${likersModalHtml}
        ${reviewersModalHtml}
        ${fixLocationModalHtml}
        <main id="main" class="app-content" role="main">
          <div id="ptr-indicator" class="ptr-indicator" aria-live="polite"><span class="ptr-spinner"></span><span class="ptr-text">Pull to refresh</span></div>
          <div class="app-content-inner ${state.tab==='map'?'map-view':''} ${state.tab==='add'?'add-view':''}">${mainContent}</div>
        </main>
      `;
      if (savedNetworkSearch !== null && savedNetworkSearch !== undefined) {
        const el = document.getElementById('networkSearchInput');
        if (el) { el.value = savedNetworkSearch; state.networkSearch = savedNetworkSearch; if (hadNetworkSearchFocus) { el.focus(); el.setSelectionRange(el.value.length, el.value.length); } }
      }
      if (state.tab === 'map') setTimeout(initMap, 100);
    }

    let map = null;
    let markers = [];
    let markerCluster = null;
    let poiLayer = null;
    let userLocationMarker = null;

    function debounce(fn, ms) {
      let t = null;
      return function() { clearTimeout(t); t = setTimeout(() => fn.apply(this, arguments), ms); };
    }

    async function loadPoiMarkers(retryCount) {
      if (!map || typeof L === 'undefined') return;
      const mapRef = map;
      try {
        if (poiLayer) { try { mapRef.removeLayer(poiLayer); } catch (e) {} poiLayer = null; }
        const bounds = mapRef.getBounds();
        const s = bounds.getSouth(), w = bounds.getWest(), n = bounds.getNorth(), e = bounds.getEast();
        const reviewedKeys = new Set(getMapRestaurants().map(r => r.lat.toFixed(5) + ',' + r.lng.toFixed(5)));
        const query = '[out:json][timeout:15];(node["amenity"="restaurant"](' + s + ',' + w + ',' + n + ',' + e + ');node["amenity"="cafe"](' + s + ',' + w + ',' + n + ',' + e + ');node["amenity"="fast_food"](' + s + ',' + w + ',' + n + ',' + e + '););out body 200;';
        let data = null;
        try {
          const res = await fetch('https://overpass-api.de/api/interpreter', { method: 'POST', body: query });
          data = await res.json();
        } catch (e1) {
          try {
            const res2 = await fetch('https://overpass.kumi.systems/api/interpreter', { method: 'POST', body: query });
            data = await res2.json();
          } catch (e2) { throw e1; }
        }
        if (!data || !data.elements) {
          if ((retryCount || 0) < 1) setTimeout(function() { loadPoiMarkers((retryCount || 0) + 1); }, 2500);
          return;
        }
        if (map !== mapRef || !mapRef.getContainer().parentNode) return;
        const pois = (data.elements || []).filter(el => el.lat && el.lon).map(el => ({
          name: el.tags?.name || el.tags?.['addr:street'] || 'Restaurant',
          lat: el.lat,
          lng: el.lon
        })).filter(p => !reviewedKeys.has(p.lat.toFixed(5) + ',' + p.lng.toFixed(5)));
        poiLayer = L.layerGroup();
        pois.slice(0, 150).forEach(p => {
          const icon = L.divIcon({
            className: 'map-marker poi-marker',
            html: '<div style="background:#888;width:12px;height:12px;border-radius:50%;border:2px solid white;box-shadow:0 1px 3px rgba(0,0,0,0.3)" title="' + escapeHtml(p.name) + '"></div>',
            iconSize: [12, 12],
            iconAnchor: [6, 6]
          });
          const m = L.marker([p.lat, p.lng], { icon });
          m.bindTooltip(escapeHtml(p.name), { permanent: false, direction: 'top', className: 'poi-tooltip' });
          m.on('click', function() { window.addReviewFromMap(p.name, p.lat, p.lng); });
          poiLayer.addLayer(m);
        });
        if (map === mapRef && mapRef.getContainer().parentNode) mapRef.addLayer(poiLayer);
      } catch (e) {
        if ((retryCount || 0) < 1) setTimeout(function() { loadPoiMarkers((retryCount || 0) + 1); }, 2500);
      }
    }

    window.addReviewFromMap = function(name, lat, lng) {
      if (!map) return;
      window._pendingPoiAdd = { name: name || 'Restaurant', lat: lat, lng: lng };
      const popup = L.popup().setLatLng([lat, lng]).setContent(
        '<div style="padding:8px;min-width:200px"><p style="margin:0 0 12px 0;font-size:0.95rem">Add review for ' + escapeHtml(name || 'this place') + '?</p><div style="display:flex;gap:8px"><button onclick="window._confirmAddReviewFromPoi()" style="flex:1;padding:10px;background:#e31919;color:white;border:none;border-radius:8px;cursor:pointer;font-weight:600">Add review</button><button onclick="window._closeMapClickPopup()" style="flex:1;padding:10px;background:#666;color:white;border:none;border-radius:8px;cursor:pointer">Cancel</button></div></div>'
      ).openOn(map);
      window._mapClickPopup = popup;
    };
    window._confirmAddReviewFromPoi = function() {
      const p = window._pendingPoiAdd;
      window._pendingPoiAdd = null;
      if (window._mapClickPopup && map) { try { map.removeLayer(window._mapClickPopup); } catch(e) {} window._mapClickPopup = null; }
      if (!p) return;
      state.selectedPlace = { name: p.name, lat: p.lat, lng: p.lng };
      state.restaurantSearch = p.name;
      state.searchResults = [];
      setTab('add');
      render();
    };

    function login(name) { state.user = { displayName: name || 'Demo User' }; saveToStorage(); render(); }
    async function handleSupabaseSignUp() {
      const api = window.FOODIE_API;
      if (!api?.enabled) return;
      const name = (document.getElementById('authDisplayName')?.value || '').trim().slice(0, MAX_DISPLAY_NAME);
      const email = (document.getElementById('authEmail')?.value || '').trim();
      const password = (document.getElementById('authPassword')?.value || '');
      const errEl = document.getElementById('authError');
      if (!name || !email || !password) { if (errEl) errEl.textContent = 'Please fill in all fields'; return; }
      if (password.length < 6) { if (errEl) errEl.textContent = 'Password must be at least 6 characters'; return; }
      if (errEl) errEl.textContent = '';
      try {
        const connectParam = state.pendingConnect || (function(){ try { return localStorage.getItem('foodie_pendingConnect'); } catch(e){ return null; } })();
        const signUpData = await api.signUp(email, password, name, connectParam || undefined);
        const stored = await api.loadData(signUpData?.session || signUpData?.user);
        if (!stored.user && signUpData?.user) {
          const prof = await api.getProfileByUserId(signUpData.user.id);
          stored.user = { id: signUpData.user.id, displayName: prof?.display_name || signUpData.user.email?.split('@')[0] || 'User' };
        }
        if (stored.user) {
          state.user = stored.user; state.reviews = stored.reviews || []; state.comments = stored.comments || {}; state.connections = stored.connections || {}; state.connectionRequests = stored.connectionRequests || []; state.saved = stored.saved || []; state.notifications = stored.notifications || []; state.profiles = stored.profiles || {}; state.privateNotes = stored.privateNotes || {}; state.groupLists = stored.groupLists || {}; state.trustScores = stored.trustScores || {}; state.groups = stored.groups || [];
          state.tab = 'feed'; state.panel = 'main';
          if (state.pendingConnect && state.pendingConnect !== state.user.displayName) { state.tab = 'network'; state.panel = 'network'; state.addConnectionInput = state.pendingConnect; state.pendingConnect = null; }
          render();
        } else {
          errEl.textContent = 'Check your email to confirm your account, then log in.';
        }
      } catch (e) { if (errEl) errEl.textContent = e.message || e.toString?.() || 'Sign up failed'; }
    }
    async function handleForgotPassword() {
      const api = window.FOODIE_API;
      if (!api?.enabled) return;
      const email = (document.getElementById('authForgotEmail')?.value || '').trim();
      const errEl = document.getElementById('authError');
      if (!email) { if (errEl) errEl.textContent = 'Please enter your email'; return; }
      if (errEl) errEl.textContent = '';
      try {
        await api.resetPasswordForEmail(email);
        if (errEl) { errEl.style.color = '#7bed9f'; errEl.textContent = 'Check your email for a reset link.'; }
      } catch (e) { if (errEl) { errEl.style.color = '#ff6b6b'; errEl.textContent = e.message || 'Could not send reset email'; } }
    }
    async function handleSetNewPassword() {
      const api = window.FOODIE_API;
      if (!api?.enabled) return;
      const newPw = (document.getElementById('authNewPassword')?.value || '');
      const confirmPw = (document.getElementById('authConfirmPassword')?.value || '');
      const errEl = document.getElementById('authError');
      if (!newPw || newPw.length < 6) { if (errEl) errEl.textContent = 'Password must be at least 6 characters'; return; }
      if (newPw !== confirmPw) { if (errEl) errEl.textContent = 'Passwords do not match'; return; }
      if (errEl) errEl.textContent = '';
      try {
        await api.updateUserPassword(newPw);
        state.authMode = 'signup';
        if (history.replaceState) history.replaceState({}, '', location.pathname);
        const stored = await api.loadData();
        if (stored.user) {
          state.user = stored.user; state.reviews = stored.reviews || []; state.comments = stored.comments || {}; state.connections = stored.connections || {}; state.connectionRequests = stored.connectionRequests || []; state.saved = stored.saved || []; state.notifications = stored.notifications || []; state.profiles = stored.profiles || {}; state.privateNotes = stored.privateNotes || {}; state.groupLists = stored.groupLists || {}; state.trustScores = stored.trustScores || {}; state.groups = stored.groups || [];
          state.tab = 'feed'; state.panel = 'main';
          if (state.pendingConnect && state.pendingConnect !== state.user.displayName) { state.tab = 'network'; state.panel = 'network'; state.addConnectionInput = state.pendingConnect; state.pendingConnect = null; }
        }
        render();
      } catch (e) { if (errEl) errEl.textContent = e.message || 'Could not set password'; }
    }
    async function handleSupabaseSignIn() {
      const api = window.FOODIE_API;
      if (!api?.enabled) return;
      const email = (document.getElementById('authEmail')?.value || '').trim();
      const password = (document.getElementById('authPassword')?.value || '');
      const errEl = document.getElementById('authError');
      if (!email || !password) { if (errEl) errEl.textContent = 'Please enter email and password'; return; }
      if (errEl) errEl.textContent = '';
      try {
        const signInData = await api.signIn(email, password);
        const stored = await api.loadData(signInData?.session || signInData?.user);
        if (!stored.user && signInData?.user) {
          const prof = await api.getProfileByUserId(signInData.user.id);
          stored.user = { id: signInData.user.id, displayName: prof?.display_name || signInData.user.email?.split('@')[0] || 'User' };
          stored.reviews = stored.reviews || []; stored.comments = stored.comments || {}; stored.connections = stored.connections || {}; stored.connectionRequests = stored.connectionRequests || []; stored.saved = stored.saved || []; stored.notifications = stored.notifications || []; stored.profiles = stored.profiles || {}; stored.privateNotes = stored.privateNotes || {}; stored.groupLists = stored.groupLists || {}; stored.trustScores = stored.trustScores || {};
        }
        if (stored.user) {
          state.user = stored.user; state.reviews = stored.reviews || []; state.comments = stored.comments || {}; state.connections = stored.connections || {}; state.connectionRequests = stored.connectionRequests || []; state.saved = stored.saved || []; state.notifications = stored.notifications || []; state.profiles = stored.profiles || {}; state.privateNotes = stored.privateNotes || {}; state.groupLists = stored.groupLists || {}; state.trustScores = stored.trustScores || {}; state.groups = stored.groups || [];
          state.tab = 'feed'; state.panel = 'main';
          if (state.pendingConnect && state.pendingConnect !== state.user.displayName) { state.tab = 'network'; state.panel = 'network'; state.addConnectionInput = state.pendingConnect; state.pendingConnect = null; }
          render();
        } else {
          errEl.textContent = 'Log in failed. If you just signed up, check your email to confirm.';
        }
      } catch (e) { if (errEl) errEl.textContent = e.message || e.toString?.() || 'Log in failed'; }
    }
    async function logout() {
      if (window.FOODIE_API?.enabled) {
        await window.FOODIE_API.signOut();
      }
      state.user = null;
      localStorage.removeItem(STORAGE_KEYS.user);
      render();
    }
    function clearAllData() {
      state.user = null;
      state.reviews = DEFAULT_REVIEWS.map(r => ({ ...r, cuisine: r.cuisine || 'Various', price: r.price || 2, verifiedVisit: r.verifiedVisit, wouldGoAgain: r.wouldGoAgain !== false }));
      state.comments = {}; state.connections = {}; state.connectionRequests = []; state.saved = []; state.notifications = []; state.profiles = {}; state.privateNotes = {}; state.groupLists = {}; state.trustScores = {};
      Object.values(STORAGE_KEYS).forEach(k => localStorage.removeItem(k));
      render();
    }
    function setTab(t) { state.tab = t; state.panel = t === 'network' ? 'network' : (t === 'groups' ? 'groups' : 'main'); if (t !== 'add') state.editingReview = null; render(); if (t === 'map') { requestUserLocationIfNeeded(function(loc){ if (loc && state.tab==='map' && map && !state.mapFocusRestaurant) map.setView([loc.lat,loc.lng],14); }); setTimeout(initMap, 200); } if (t === 'add') { requestUserLocationIfNeeded(); loadNsfwModel(); } if (t === 'groups' && state.user && window.FOODIE_API?.enabled) refreshFeed(); }
    function filterMap(f) { state.mapFilter = f; render(); setTimeout(function(){ if (state.tab === 'map') initMap(); }, 150); }
    function setRating(n) { state.rating = n; render(); }

    async function initMap() {
      const el = document.getElementById('map-container');
      if (!el) return;
      if (typeof L === 'undefined') { setTimeout(initMap, 100); return; }
      if (!el.offsetHeight) el.style.minHeight = '400px';
      state._geocodedReviewIds = state._geocodedReviewIds || new Set();
      const invalidIndia = state.reviews.filter(r => {
        const la = parseFloat(r.lat), ln = parseFloat(r.lng);
        const invalid = isNaN(la) || isNaN(ln) || la < -90 || la > 90 || ln < -180 || ln > 180;
        const looksDefault = (la === 0 && ln === 0) || (Math.abs(la - 37.37) < 0.1 && Math.abs(ln - (-122.03)) < 0.1);
        const outsideIndia = la < 8 || la > 35 || ln < 68 || ln > 97;
        const name = (r.restaurant || '').trim();
        const suggestsIndia = name.length > 3 && /india|thane|mumbai|delhi|bangalore|chennai|pune|hyderabad|kolkata/i.test(name);
        return suggestsIndia && name.length > 5 && !state._geocodedReviewIds.has(r.id) && (invalid || looksDefault || outsideIndia);
      });
      let geocodedAny = false;
      for (const r of invalidIndia.slice(0, 3)) {
        const geocoded = await geocodePlace(r.restaurant || '', 20, 77);
        if (geocoded) { r.lat = geocoded.lat; r.lng = geocoded.lng; geocodedAny = true; if (window.FOODIE_API?.enabled) { try { await window.FOODIE_API.fixReviewLocation(r.id, geocoded.lat, geocoded.lng); } catch(e) {} } else saveToStorage(); }
        state._geocodedReviewIds.add(r.id);
      }
      if (geocodedAny) { if (!window.FOODIE_API?.enabled) saveToStorage(); render(); return; }
      try {
        if (map && !state.mapFocusRestaurant) {
          const c = map.getCenter();
          const z = map.getZoom();
          state._mapView = { lat: c.lat, lng: c.lng, zoom: z };
        }
        if (map) map.remove();
      } catch (e) {}
      map = null; markers = []; markerCluster = null; poiLayer = null; userLocationMarker = null;
      const restaurants = getMapRestaurants();
      const q = (state.mapSearch || '').toLowerCase().trim();
      const filtered = q ? restaurants.filter(r => (r.name||'').toLowerCase().includes(q)) : restaurants;
      const toShow = filtered.length ? filtered : restaurants;
      const center = toShow.length ? [toShow[0].lat, toShow[0].lng] : [37.37, -122.03];
      map = L.map('map-container', { minZoom: 1, maxZoom: 19, zoomAnimation: false }).setView(center, 10);
      L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager_labels_under/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap &copy; CARTO', subdomains: 'abcd', maxZoom: 20 }).addTo(map);

      map.on('click', function(e) {
        if (e.originalEvent.target.closest('.leaflet-marker-icon') || e.originalEvent.target.closest('.leaflet-popup')) return;
        const lat = e.latlng.lat, lng = e.latlng.lng;
        const popup = L.popup().setLatLng(e.latlng).setContent(
          '<div style="padding:8px;min-width:200px"><p style="margin:0 0 12px 0;font-size:0.95rem">Add a review at this location?</p><div style="display:flex;gap:8px"><button onclick="window._confirmAddReviewAtMapClick(' + lat + ',' + lng + ')" style="flex:1;padding:10px;background:#e31919;color:white;border:none;border-radius:8px;cursor:pointer;font-weight:600">Add review</button><button onclick="window._closeMapClickPopup()" style="flex:1;padding:10px;background:#666;color:white;border:none;border-radius:8px;cursor:pointer">Cancel</button></div></div>'
        ).openOn(map);
        window._mapClickPopup = popup;
      });
      window._confirmAddReviewAtMapClick = async function(lat, lng) {
        if (window._mapClickPopup && map) { try { map.removeLayer(window._mapClickPopup); } catch(e) {} window._mapClickPopup = null; }
        const useName = state.pickOnMapRestaurantName || '';
        state.pickOnMapRestaurantName = null;
        const name = useName || (await reverseGeocode(lat, lng));
        state.selectedPlace = { name: name, lat: lat, lng: lng };
        state.restaurantSearch = name;
        state.searchResults = [];
        setTab('add');
        render();
      };
      window._closeMapClickPopup = function() {
        window._pendingPoiAdd = null;
        if (window._mapClickPopup && map) { try { map.removeLayer(window._mapClickPopup); } catch(e) {} window._mapClickPopup = null; }
      };

      setTimeout(function() { loadPoiMarkers(0); }, 900);
      const levelColors = { 0: '#7c4dff', 1: '#006CE0', 2: '#FF8D00', 3: '#e31919' };
      window._mapPopupRestaurants = toShow.map(r => ({ name: r.name || '', lat: r.lat, lng: r.lng }));
      function buildMapPopup(r, idx) {
        const color = levelColors[r.level] ?? levelColors[2];
        const levelLabel = r.level === 0 ? 'Discover' : r.level === 1 ? '1st level' : r.level === 2 ? '2nd level' : 'Your review';
        const firstPhoto = (r.reviews || []).flatMap(rev => getReviewPhotoUrls(rev)).find(Boolean);
        const cuisineStr = (r.cuisines && r.cuisines.length) ? r.cuisines.join(', ') : 'Various';
        const priceStr = PRICE_LABELS[(r.price||2)-1] || '$$';
        const dirUrl = 'https://www.google.com/maps/dir/?api=1&destination=' + r.lat + ',' + r.lng;
        return '<div class="map-popup" style="min-width:180px;max-width:260px">' +
          (firstPhoto ? '<img src="' + firstPhoto + '" alt="" style="width:100%;height:80px;object-fit:cover;border-radius:8px;margin-bottom:6px" onerror="this.style.display=\'none\'">' : '') +
          '<strong>' + escapeHtml(r.name||'') + '</strong><br>' +
          '<span style="color:' + color + '">● ' + levelLabel + '</span><br>' +
          '<span style="font-size:0.85rem;color:#666">' + cuisineStr + ' · ' + priceStr + '</span><br>' +
          '<span style="font-size:0.85rem">' + (r.avgRating !== '-' ? r.avgRating + ' ★' : '-') + ' · ' + (r.reviews?.length||0) + ' review' + ((r.reviews?.length||0)===1?'':'s') + '</span><br>' +
          '<a href="' + dirUrl + '" target="_blank" rel="noopener" style="display:inline-block;margin-top:8px;padding:6px 12px;background:#0a66c2;color:white;border-radius:6px;text-decoration:none;font-size:0.9rem">Get directions</a> ' +
          '<button onclick="window._viewRestaurantFromMapIdx(' + idx + ')" style="margin-top:8px;padding:6px 12px;background:#e31919;color:white;border:none;border-radius:6px;cursor:pointer;font-size:0.9rem">View details</button> ' +
          '<button onclick="window._openFixLocationFromMapIdx(' + idx + ')" style="margin-top:8px;padding:6px 12px;background:#333;color:white;border:none;border-radius:6px;cursor:pointer;font-size:0.9rem">Fix location</button>' +
          '</div>';
      }
      window._viewRestaurantFromMapIdx = function(idx) {
        const arr = window._mapPopupRestaurants;
        if (arr && arr[idx]) { const x = arr[idx]; viewRestaurantReviews(x.name, x.lat, x.lng); }
      };
      window._openFixLocationFromMapIdx = function(idx) {
        const arr = window._mapPopupRestaurants;
        if (arr && arr[idx]) { const x = arr[idx]; openFixLocationModal(x.name, x.lat, x.lng); }
      };
      if (typeof L !== 'undefined' && L.markerClusterGroup) {
        if (markerCluster) map.removeLayer(markerCluster);
        markerCluster = L.markerClusterGroup();
        toShow.forEach((r, idx) => {
          const color = levelColors[r.level] || levelColors[2];
          const size = getMapBubbleSize(r.avgRating, r.reviews?.length || 0);
          const ratingText = r.avgRating !== '-' ? r.avgRating : '';
          const fontSize = size >= 24 ? Math.round(size * 0.45) : (size >= 20 ? 8 : 0);
          const icon = L.divIcon({
            className: 'map-marker',
            html: `<div style="background:${color};width:${size}px;height:${size}px;border-radius:50%;border:3px solid white;box-shadow:0 2px 5px rgba(0,0,0,0.3);display:flex;align-items:center;justify-content:center;color:white;font-weight:700;font-size:${fontSize}px;line-height:1;text-shadow:0 1px 2px rgba(0,0,0,0.3)">${ratingText}</div>`,
            iconSize: [size, size],
            iconAnchor: [size/2, size/2]
          });
          const m = L.marker([r.lat, r.lng], { icon }).bindPopup(buildMapPopup(r, idx));
          markerCluster.addLayer(m);
          markers.push(m);
        });
        map.addLayer(markerCluster);
      } else {
        toShow.forEach((r, idx) => {
          const color = levelColors[r.level] || levelColors[2];
          const size = getMapBubbleSize(r.avgRating, r.reviews?.length || 0);
          const ratingText = r.avgRating !== '-' ? r.avgRating : '';
          const fontSize = size >= 24 ? Math.round(size * 0.45) : (size >= 20 ? 8 : 0);
          const icon = L.divIcon({
            className: 'map-marker',
            html: `<div style="background:${color};width:${size}px;height:${size}px;border-radius:50%;border:3px solid white;box-shadow:0 2px 5px rgba(0,0,0,0.3);display:flex;align-items:center;justify-content:center;color:white;font-weight:700;font-size:${fontSize}px;line-height:1;text-shadow:0 1px 2px rgba(0,0,0,0.3)">${ratingText}</div>`,
            iconSize: [size, size],
            iconAnchor: [size/2, size/2]
          });
          const m = L.marker([r.lat, r.lng], { icon }).addTo(map).bindPopup(buildMapPopup(r, idx));
          markers.push(m);
        });
      }
      if (state.mapFocusRestaurant) {
        const f = state.mapFocusRestaurant;
        map.setView([f.lat, f.lng], 15);
      } else if (state._mapView) {
        map.setView([state._mapView.lat, state._mapView.lng], state._mapView.zoom);
        state._mapView = null;
      } else if (state.userLocation) {
        map.setView([state.userLocation.lat, state.userLocation.lng], 14);
      } else if (toShow.length === 1) map.setView([toShow[0].lat, toShow[0].lng], 15);
      else if (toShow.length > 1) {
        const bounds = L.latLngBounds(toShow.map(r => [r.lat, r.lng]));
        map.fitBounds(bounds, { padding: [20, 20], maxZoom: 15, minZoom: 1 });
      }
      if (state.userLocation && userLocationMarker) {
        try { if (map.hasLayer(userLocationMarker)) map.removeLayer(userLocationMarker); } catch (e) {}
        const icon = L.divIcon({
          className: 'user-location-marker',
          html: '<div style="width:20px;height:20px;background:#2196F3;border:3px solid white;border-radius:50%;box-shadow:0 2px 6px rgba(0,0,0,0.4)"></div>',
          iconSize: [20, 20],
          iconAnchor: [10, 10]
        });
        userLocationMarker = L.marker([state.userLocation.lat, state.userLocation.lng], { icon }).addTo(map);
        userLocationMarker.bindPopup('You are here');
      } else userLocationMarker = null;
      if (state.mapFocusRestaurant) {
        const f = state.mapFocusRestaurant;
        const tol = 0.0001;
        const m = markers.find(mk => Math.abs(mk.getLatLng().lat - f.lat) < tol && Math.abs(mk.getLatLng().lng - f.lng) < tol);
        if (m) setTimeout(function(){ m.openPopup(); }, 300);
        else {
          const dirUrl = 'https://www.google.com/maps/dir/?api=1&destination=' + f.lat + ',' + f.lng;
          window._mapPopupRestaurants = [{ name: f.name || '', lat: f.lat, lng: f.lng }];
          L.popup().setLatLng([f.lat, f.lng]).setContent('<div class="map-popup" style="min-width:180px"><strong>' + escapeHtml(f.name||'') + '</strong><br><a href="' + dirUrl + '" target="_blank" rel="noopener" style="display:inline-block;margin-top:8px;padding:6px 12px;background:#0a66c2;color:white;border-radius:6px;text-decoration:none;font-size:0.9rem">Get directions</a> <button onclick="window._viewRestaurantFromMapIdx(0)" style="margin-top:8px;padding:6px 12px;background:#e31919;color:white;border:none;border-radius:6px;cursor:pointer;font-size:0.9rem">View details</button> <button onclick="window._openFixLocationFromMapIdx(0)" style="margin-top:8px;padding:6px 12px;background:#333;color:white;border:none;border-radius:6px;cursor:pointer;font-size:0.9rem">Fix location</button></div>').openOn(map);
        }
        state.mapFocusRestaurant = null;
      }
    }

    function zoomMapToSearch() {
      if (state.tab !== 'map' || !map) return;
      initMap();
    }

    function handleDeepLink() {
      const params = new URLSearchParams(location.search);
      const reviewId = params.get('review');
      const connectName = params.get('connect');
      if (connectName) {
        const name = decodeURIComponent(connectName).trim();
        if (name) { state.pendingConnect = name; try { localStorage.setItem('foodie_pendingConnect', name); } catch(e) {} }
        const p = new URLSearchParams(location.search); p.delete('connect'); const q = p.toString() ? '?' + p.toString() : ''; if (history.replaceState) history.replaceState({}, '', location.pathname + q);
      }
      if (!state.pendingConnect) { try { const stored = localStorage.getItem('foodie_pendingConnect'); if (stored) state.pendingConnect = stored; } catch(e) {} }
      if (state.pendingConnect && state.user && state.pendingConnect !== state.user.displayName) {
        const toConnect = state.pendingConnect;
        state.pendingConnect = null;
        try { localStorage.removeItem('foodie_pendingConnect'); } catch(e) {}
        if (window.FOODIE_API?.enabled && window.FOODIE_API.connectFromInvite) {
          window.FOODIE_API.connectFromInvite(toConnect).then(function(ok) {
            if (ok) { showListToast('You\'re now connected with ' + toConnect + '!'); refreshFeed(); }
            else { sendConnectionRequest(toConnect).then(function() { showListToast('Connection request sent to ' + toConnect + '.'); }); }
          });
        } else {
          sendConnectionRequest(toConnect).then(function() { showListToast('Connection request sent to ' + toConnect + '.'); });
        }
        render();
      }
      if (reviewId && state.user) {
        const r = state.reviews.find(x => x.id === reviewId);
        if (r) {
          state.tab = 'feed';
          state.panel = 'main';
          render();
          setTimeout(() => {
            const el = document.querySelector('[data-review-id="' + reviewId + '"]');
            if (el) el.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }, 300);
        }
      }
    }

    window.viewRestaurantDetail = viewRestaurantDetail;
    window.viewRestaurantFromReviewId = viewRestaurantFromReviewId;
    window.viewRestaurantReviews = viewRestaurantReviews;
    window.showRestaurantOnMap = showRestaurantOnMap;
    window.openFixLocationModal = openFixLocationModal;
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('sw.js?v=9').then(reg => {
        setInterval(() => reg.update(), 30 * 60 * 1000);
        document.addEventListener('visibilitychange', () => { if (document.visibilityState === 'visible') reg.update(); });
      }).catch(() => {});
      navigator.serviceWorker.addEventListener('controllerchange', () => location.reload());
    }
    bootstrapApp().catch(function(e) {
      var msg = e && (e.message || e.toString) ? (e.message || e.toString()) : 'Unknown error';
      var app = document.getElementById('app');
      if (app) app.innerHTML = '<div style="padding:24px;max-width:400px;margin:0 auto;background:#fff3cd;border:1px solid #ffc107;border-radius:8px;color:#856404"><p style="margin-bottom:12px"><strong>Something went wrong.</strong></p><p style="font-size:0.9rem;margin-bottom:12px">' + (msg.replace(/</g,'&lt;').substring(0,200)) + '</p><button onclick="location.reload()" style="padding:10px 20px;background:#e31919;color:white;border:none;border-radius:8px;cursor:pointer">Reload</button></div>';
      console.error('Foodie bootstrap error:', e);
    });
    window.addEventListener('popstate', () => { const p = new URLSearchParams(location.search); if (p.get('review')) handleDeepLink(); });
  </script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js" crossorigin=""></script>
</body>
</html>
